C---------------------------------------------------------------------------------------------
C
C Fortran Program Name: nos_ofs_create_forcing_met.f
C
C Directory Location:  
C /gpfs/d/marine/save/wx21az/nos_ofs/sorc/nos_ofs_create_forcing_met.fd
C
C Technical Contact(s):   Name:  Aijun Zhang           Org:  NOS/CO-OPS/OD
C                         Phone: 301-7132890 ext. 127  E-Mail: aijun.zhang@noaa.gov
C
C Abstract:
C   This program is used to generated surface forcing file for ROMS from
C   NCEP operational forecast products of grib2 files. The wind is rotated to earth coordinates 
C   
C
C
C Usage: ./nos_ofs_create_forcing_met  < control.ctl
C
C Input Parameters:
C  OFS        :  Name of Operational Forecast System, e.g., NGOFS
C  DBASE      : Name of NCEP operational meteological products such as NAM, GFS, or RTMA 
C  Time       : Start time,e.g., 2008 10 15 00
C  IGRD       : indicator of horizontal interpolation method
C              =0: The output is on the native AWIPS Grid 218 (coarse grid)
C              =1: The output is on the ocean model grid (FVCOM), remesh routine (from Tom Gross)
C                  is used for spatial interpolation 
C              =2: This Option doesn't work for FVCOM, bicubic routine (from ROMS)
C                  is used for spatial interpolation 
C              =3: This Option doesn't work for FVCOM, bilinear routine (from ROMS)
C                  is used for spatial interpolation 
C              =4: The output is on the ocean model grid (FVCOM), nature neighbors (from Great Lakes)
C                  is used for spatial interpolation 
C OUTPUTFILE  : Output file name   
C MINLON      :longitude of lower left/southwest corner to cover the OFS domain
C MINLAT      :latitude of lower left /southwest corner to cover the OFS domain
C MINLON      :longitude of upper right/northeast corner to cover the OFS domain
C MINLAT      :latitude of  upper right/northeast corner to cover the OFS domain
C
C Language:              (ex. Fortran 90)
C
C Compiling/Linking Syntax: make -f Make_nos_ofs_create_forcing_met
C
C Target Computer: DEW/MIST at NCEP
C
C Estimated Execution Time:
C
C Suboutines/Functions Called:
C          Name                        Directory Location                              Description
C
C Input Files:
C  Unit No.       Name                 Directory  Location                              Description
C  if IGRD > 0, ocean model grid netCDF file is required to read in FVCOM grid information
C  all ascii files generated by script program "nos_ofs_create_forcing_met.sh"
 
C Output Files:
C  Unit No.        Name                Directory Location                              Description
C
C Libraries Used: see the makefile
C  
C Error Conditions:
C
C Author Name:   Aijun Zhang              Creation Date: Oct. 16, 2008
C
C Revisions:
C         Date                  Author                             Description
C       01/21/2010            Aijun Zhang             add SCALE_HFLUX to reduce heat flux of NAM 
C
C Remarks:
C
C
C --------------------------------------------------------------------------------------------
      use grib_mod
!      use params
      include 'netcdf.inc'
      parameter (PI=3.1415926, D2R=PI/180.0)
      type(gribfield) :: gfld
      integer,dimension(200) :: jids,jpdt,jgdt
!      integer,dimension(16,3) :: iparms  
      character(len=8) :: pabbrev
      character(len=20) :: labbrev
      character(len=120) :: tabbrev
      character*120 OFS*5,DBASE*10,DBASE_MET_FOR*10, OCEAN_MODEL*20
      character*120 header,BUFFER,GRIBFILE,GRIDFILE,OUTPUTFILE,FNAME
      character*120 OUTPUTFILE1,OUTPUTFILE2,OUTPUTFILE3,landmask
      INTEGER BASE_DATE(4),CYC
      real minlon,minlat,maxlat,maxlon
      real*8 jdays,jdaye,jbase_date,JULIAN,yearb,monthb,dayb,hourb
      real*8 jday,jday0,js_etss,je_etss
      integer grbunit
      real latsw,lonsw,LaD,LoV,dx_grb,LON_XX_P,LAT_XX_P
cc allocatable variables for NCEP meteorological products (NAM, GFS, RTMA,etc.)
      real, allocatable :: uwind(:,:)
      real, allocatable :: vwind(:,:)
      real, allocatable :: pair(:,:)
      real, allocatable :: tair(:,:)
      real, allocatable :: tdair(:,:)  ! dew point
      real, allocatable :: qair(:,:)
      real, allocatable :: tcdc(:,:)
      real, allocatable :: dswrf(:,:)
      real, allocatable :: dlwrf(:,:)
      real, allocatable :: uswrf(:,:)
      real, allocatable :: ulwrf(:,:)
      real, allocatable :: lhtfl(:,:)
      real, allocatable :: shtfl(:,:)
      real, allocatable :: nflux(:,:)
      real, allocatable :: prate(:,:)
      real, allocatable :: spfh(:,:)
      real, allocatable :: netlwrf(:,:)
      real, allocatable :: netswrf(:,:)
      real, allocatable :: evp (:,:)
      real, allocatable :: lon  (:,:)
      real, allocatable :: lat  (:,:)
      real, allocatable :: land  (:,:)
      real, allocatable :: lonsub  (:,:)
      real, allocatable :: latsub  (:,:)
      real, allocatable :: landsub  (:,:)
      real, allocatable :: maskm_e(:,:)
      integer, allocatable :: IFILL(:,:),JFILL(:,:)
      integer, allocatable :: ISHORE(:),JSHORE(:)
 
cc allocatable variables  for ocean models with curvilinear grid
      real, allocatable :: lonm  (:,:)
      real, allocatable :: latm  (:,:)
      real, allocatable :: angm  (:,:)
      real, allocatable :: hm  (:,:)
      real, allocatable :: uwindm(:,:)
      real, allocatable :: vwindm(:,:)
      real, allocatable :: pairm(:,:)
      real, allocatable :: tairm(:,:)
      real, allocatable :: tdairm(:,:)
      real, allocatable :: tcdcm(:,:)
      real, allocatable :: evpm(:,:)
      real, allocatable :: qairm(:,:)
      real, allocatable :: dswrfm(:,:)
      real, allocatable :: dlwrfm(:,:)
      real, allocatable :: uswrfm(:,:)
      real, allocatable :: ulwrfm(:,:)
      real, allocatable :: lhtflm(:,:)
      real, allocatable :: shtflm(:,:)
      real, allocatable :: nfluxm(:,:)
      real, allocatable :: pratem(:,:)
      real, allocatable :: spfhm(:,:)
      real, allocatable :: netlwrfm(:,:)
      real, allocatable :: netswrfm(:,:)
      real, allocatable :: Iout(:,:)
      real, allocatable :: Jout(:,:)
      integer, allocatable :: weightnodes(:,:)  ! NNMODEL,3)
      real, allocatable :: weights(:,:)       ! NNMODEL,3)
      integer n3(3)
      real w3(3)
C  temporary array
      real, allocatable :: tmp1 (:,:)
      real, allocatable :: tmp2 (:,:)
      real, allocatable :: oned1(:)
      real, allocatable :: oned2(:)
      real, allocatable :: oned3(:)
      real, allocatable :: oned4(:)
      real, allocatable :: oned5(:)
      real, allocatable :: oned6(:)
      real, allocatable :: twod(:,:)
      real Uwind_L,Vwind_L,pair_L,tair_L,qair_L,prate_L,rh_L,spfh_L
      real dswrf_L,dlwrf_L,uswrf_L,ulwrf_L,lhtfl_L,shtflm_L,nflux_L
      real netlwrf_L,netswrf_L,tcdc_L,tdair_L,evp_L
      real*4, allocatable :: XINP(:)
      real*4, allocatable :: YINP(:)
      real*4, allocatable :: ZINP(:)
      real*4, allocatable :: XOUT(:)
      real*4, allocatable :: YOUT(:)
      real*4, allocatable :: ZOUT(:)
      CHARACTER*120 FMT
      INTEGER ncid,acid,fcid,pcid,ncfluxid
      LOGICAL FEXIST,FOPEN
      CHARACTER (LEN=10) BIG_BEN(3),CURRENT_TIME*20
      CHARACTER globalstr(9)*120
      INTEGER DATE_TIME(8)
      INTEGER DAYS_PER_MONTH(12)
      DATA (DAYS_PER_MONTH(i),I=1,12) /
     &31,28,31,30,31,30,31,31,30,31,30,31/
      
       read(5,'(a)')OFS
       read(5,'(a)')DBASE
       read(5,'(a)')OCEAN_MODEL
       read(5,'(I4,3I2)')IYRS,IMMS,IDDS,IHHS
       read(5,'(I4,3I2)')IYRE,IMME,IDDE,IHHE
       read(5,*)IGRD
       read(5,'(a)')BUFFER
       do i=1,len_trim(BUFFER)
          if(BUFFER(i:I) .eq. "'" .or. BUFFER(i:I) .eq. '"')then
	    BUFFER(i:I)=' '
	  endif    
       enddo
       GRIBFILE=trim(adjustL(BUFFER))
       read(5,'(a)')BUFFER
       do i=1,len_trim(BUFFER)
          if(BUFFER(i:I) .eq. "'" .or. BUFFER(i:I) .eq. '"')then
	    BUFFER(i:I)=' '
	  endif    
       enddo
       GRIDFILE=trim(adjustL(BUFFER))
       print *,'gridfile=',trim(gridfile)
       read(5,'(a)')BUFFER
       do i=1,len_trim(BUFFER)
          if(BUFFER(i:I) .eq. "'" .or. BUFFER(i:I) .eq. '"')then
	    BUFFER(i:I)=' '
	  endif    
       enddo
       OUTPUTFILE=trim(adjustL(BUFFER))

       read(5,'(a)')BUFFER
       do i=1,len_trim(BUFFER)
          if(BUFFER(i:I) .eq. "'" .or. BUFFER(i:I) .eq. '"')then
	    BUFFER(i:I)=' '
	  endif    
       enddo
       BUFFER=trim(adjustL(BUFFER))
       read(BUFFER,'(I4,3I2)')base_date(1),base_date(2),base_date(3),
     & base_date(4)
       print *,'base_date= ',base_date
       read(5,*)minlon
       read(5,*)minlat
       read(5,*)maxlon
       read(5,*)maxlat
       read(5,*)SCALE_HFLUX
!       read(5,'(a)')BUFFER
!       do i=1,len_trim(BUFFER)
!          if(BUFFER(i:I) .eq. "'" .or. BUFFER(i:I) .eq. '"')then
!	    BUFFER(i:I)=' '
!	  endif    
!       enddo
       landmask=trim(DBASE)//'.LANDMASK'
       
1      format(I2.2,a1,I2.2,2x,I2.2,a1,i2.2,a1,I4)
      CALL DATE_AND_TIME(BIG_BEN(1),BIG_BEN(2),BIG_BEN(3),DATE_TIME)
      WRITE(CURRENT_TIME,1)DATE_TIME(5),':',DATE_TIME(6),
     &DATE_TIME(2),'/',DATE_TIME(3),'/',DATE_TIME(1)
!____________________Set global attributes string of the NetCDF
      globalstr(1)= trim(OCEAN_MODEL)//' surface forcing netCDF file'
      globalstr(2)= trim(OFS)//' surface forcing netCDF file'
      globalstr(3)= 'NCEP '//trim(DBASE)//' operational products'
      globalstr(4)= 'Grib2 file: '//trim(GRIBFILE)
      if(IGRD  .EQ. 0)then
        globalstr(5)= 'On native '//trim(DBASE)
     &               //' grid, No spatial interpolation'
      elseif(IGRD  .EQ. 1)then
        globalstr(5)= 'On '//trim(OCEAN_MODEL)
     &               //' grid, using remesh spatial interpolation'
      elseif(IGRD  .EQ. 2)then
        globalstr(5)= 'On '//trim(OCEAN_MODEL)
     &               //' grid, using bicubic spatial interpolation'
      elseif(IGRD  .EQ. 3)then
        globalstr(5)= 'On '//trim(OCEAN_MODEL)
     &               //' grid, using bilinear spatial interpolation'
      elseif(IGRD  .EQ. 4)then
        globalstr(5)= 'On '//trim(OCEAN_MODEL)
     &      //' grid, using nature neighbors spatial interpolation'
      endif
      globalstr(6)= 'Ocean Model grid file: '//trim(GRIDFILE)
      
      globalstr(7)= 'Created at time '//trim(CURRENT_TIME)
      globalstr(8)='Created by Aijun Zhang, OD/CO-OPS/NOS/NOAA'
	  
!!    read in global land-sea mask of NCEP atmospheric products
!! 
 !!________________________________________________
      IF (IGRD .GE. 0)THEN
         WRITE(*,*)'Reading ROMS grid file ...',trim(GRIDFILE)
         STATUS = NF_OPEN(trim(GRIDFILE),NF_NOWRITE, NCID_GRD)
	 IF(STATUS .NE. NF_NOERR)then
	   print *,'error message= ',status
	   stop 'open grid file failed'
	 ENDIF  
         STATUS = NF_INQ(NCID_GRD,NDIMS,NVARS,NGATTS,IDUNLIMDIM)
         DO I=1,NDIMS
            STATUS = NF_INQ_DIM(NCID_GRD,i,BUFFER,ILATID)
            STATUS = NF_INQ_DIMLEN(NCID_GRD,i,latid)
            if(trim(BUFFER) .eq. 'eta_rho')JROMS=latid
            if(trim(BUFFER) .eq. 'xi_rho')IROMS=latid
         ENDDO
	 NNMODEL=IROMS*JROMS
         ALLOCATE(lonm(IROMS,JROMS) )
	 ALLOCATE(latm(IROMS,JROMS) )
         ALLOCATE(angm(IROMS,JROMS) )
         allocate(uwindm(IROMS,JROMS))
         allocate(vwindm(IROMS,JROMS))
         allocate(pairm(IROMS,JROMS))
         allocate(tairm(IROMS,JROMS))
         allocate(tdairm(IROMS,JROMS))
         allocate(tcdcm(IROMS,JROMS))
         allocate(evpm(IROMS,JROMS))
         allocate(qairm(IROMS,JROMS))
         allocate(dswrfm(IROMS,JROMS))
         allocate(dlwrfm(IROMS,JROMS))
         allocate(uswrfm(IROMS,JROMS))
         allocate(ulwrfm(IROMS,JROMS))
         allocate(lhtflm(IROMS,JROMS))
         allocate(shtflm(IROMS,JROMS))
         allocate(pratem(IROMS,JROMS))
         allocate(spfhm(IROMS,JROMS))
         allocate(nfluxm(IROMS,JROMS))
         allocate(netlwrfm(IROMS,JROMS))
         allocate(netswrfm(IROMS,JROMS))

	 IF (IGRD .EQ. 1)THEN
            allocate(weightnodes(NNMODEL,3))
            allocate(weights(NNMODEL,3))
	 ELSE
            allocate(Iout(IROMS,JROMS))
            allocate(Jout(IROMS,JROMS))
	 ENDIF       
         STATUS = NF_INQ_VARID(NCID_GRD,'lon_rho',IDVAR)
         STATUS = NF_GET_VAR_REAL(NCID_GRD,IDVAR,lonm)
         STATUS = NF_INQ_VARID(NCID_GRD,'lat_rho',IDVAR)
         STATUS = NF_GET_VAR_REAL(NCID_GRD,IDVAR,latm)
         STATUS = NF_INQ_VARID(NCID_GRD,'angle',IDVAR)
         STATUS = NF_GET_VAR_REAL(NCID_GRD,IDVAR,angm)
         STATUS = NF_GET_ATT_TEXT(NCID_GRD,IDVAR,'units',BUFFER)
         LL=INDEX(trim(BUFFER),'degree')
         IF (LL .GT. 0) angm=angm*0.01745329
         STATUS=NF_CLOSE(NCID_GRD)
	 OPEN(33,file='lonlat_modelgrid.dat')
	 DO I=1,IROMS
	 DO J=1,JROMS
	   write(33,*)lonm(i,j),latm(i,j),i,j
	 ENDDO
	 ENDDO
	 close(33)
	 write(*,*)'xi_rho & eta_rho of ROMS grid=',IROMS,JROMS
      ENDIF  
      WRITE(*,*)'Operational FORECAST SYSTEM IS: ',TRIM(OFS)
      yearb=base_date(1)
      monthb=base_date(2)
      dayb=base_date(3)
      hourb=base_date(4)
      jbase_date=JULIAN(yearb,monthb,dayb,hourb)
      yearb=IYRS
      monthb=IMMS
      dayb=IDDS
      hourb=IHHS   !! do not need minutes to construct ETSS file name
      TIME_START=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
      yearb=IYRE
      monthb=IMME
      dayb=IDDE
      hourb=IHHE   !! do not need minutes to construct ETSS file name
      TIME_END=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
      PRINT *,'time range= ',TIME_START,TIME_END

!-----------------------------------------------------------------------
!
!  Open the GRIB file
!
!-----------------------------------------------------------------------
      lengrb=LEN_TRIM(gribfile)
      CALL rdgrb2dims(gribfile,lengrb,IM,JM,iret
     & ,latsw,lonsw,LaD,LoV,dx_grb,GRIDID)
      write(*,*)latsw,lonsw,LaD,LoV,dx_grb
      write(*,*)'IM & JM= ',IM,JM
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc allocate sizes of arrays for NCEP operational products 
cc from control file
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      allocate(lon(IM,JM))
      allocate(lat(IM,JM))
CC read in lon and lat of native atmos model grid from grib2 file instead of computing in this program
CC the longitude is converted into negative for western hemisphere
      FNAME='UGRD.'//trim(DBASE)
      INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
      IF(FEXIST)THEN
         CLOSE(81)
         OPEN(81,file=trim(FNAME))
!         READ(81,*)IYR,IMM,IDD,IHH
         READ(81,'(a)')BUFFER
         DO J=1,JM
         DO I=1,IM
	  READ(81,*)x,y,value
	     if (x .GT. 180.0)x=x-360    ! convert longitude in west hemisphere into negative 
             lon(i,j)=x
	     lat(i,j)=y
         ENDDO
         ENDDO
         CLOSE(81)
      ELSE          
          FNAME='TMP.'//trim(DBASE)
          INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
          IF(FEXIST)THEN
            IF(.NOT. FOPEN)THEN
	       CLOSE(81)
               OPEN(81,file=trim(FNAME))
!               READ(81,*)IYR,IMM,IDD,IHH
               READ(81,'(a)')BUFFER
               DO J=1,JM
               DO I=1,IM
	          READ(81,*)x,y,value
	          if (x .GT. 180.0)x=x-360    ! convert longitude in west hemisphere into negative 
                  lon(i,j)=x
	          lat(i,j)=y
               ENDDO
               ENDDO
               CLOSE(81)
	    ENDIF
	  ENDIF
      ENDIF	 	 
      IF (trim(DBASE) .EQ. 'NDFD')THEN
        FNAME='WIND.'//trim(DBASE)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
        IF(FEXIST)THEN
         CLOSE(81)
         OPEN(81,file=trim(FNAME))
!         READ(81,*)IYR,IMM,IDD,IHH
         READ(81,'(a)')BUFFER
         DO J=1,JM
         DO I=1,IM
           READ(81,*)x,y,value
           if (x .GT. 180.0)x=x-360 
           lon(i,j)=x
           lat(i,j)=y
         ENDDO
         ENDDO
         CLOSE(81)
        ENDIF
      ENDIF
      IMIN=99999
      IMAX=-9999
      JMIN=99999
      JMAX=-9999
CC select subdomain I and J index        
      DO I=1,IM
      DO J=1,JM
         IF(lon(i,j) .GE. minlon .and. lon(i,j) .LE. maxlon
     &    .and. lat(i,j) .GE. minlat .and. lat(i,j) .LE. maxlat)then
         IF(I .LT. IMIN)IMIN=I 	  
         IF(I .GT. IMAX)IMAX=I 	  
         IF(J .LT. JMIN)JMIN=J 	  
         IF(J .GT. JMAX)JMAX=J
	ENDIF
      ENDDO
      ENDDO	  	  
      write(*,*)IMIN,IMAX,JMIN,JMAX	        
      ISUB=IMAX-IMIN+1	 
      JSUB=JMAX-JMIN+1	 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc allocate sizes of arrays for NAM12 products 
cc from control file
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      NNSUB=ISUB*JSUB
      allocate(lonsub(ISUB,JSUB))
      allocate(latsub(ISUB,JSUB))
      allocate(uwind(ISUB,JSUB))
      allocate(vwind(ISUB,JSUB))
      allocate(pair(ISUB,JSUB))
      allocate(tair(ISUB,JSUB))
      allocate(tdair(ISUB,JSUB))
      allocate(tcdc(ISUB,JSUB))
      allocate(evp(ISUB,JSUB))
      allocate(qair(ISUB,JSUB))
      allocate(dswrf(ISUB,JSUB))
      allocate(dlwrf(ISUB,JSUB))
      allocate(uswrf(ISUB,JSUB))
      allocate(ulwrf(ISUB,JSUB))
      allocate(lhtfl(ISUB,JSUB))
      allocate(shtfl(ISUB,JSUB))
      allocate(prate(ISUB,JSUB))
      allocate(spfh(ISUB,JSUB))
      allocate(nflux(ISUB,JSUB))
      allocate(netlwrf(ISUB,JSUB))
      allocate(netswrf(ISUB,JSUB))
      allocate(landsub(ISUB,JSUB))
      allocate(tmp1(IM,JM))
      allocate(tmp2(ISUB,JSUB))
      DO J=1,JSUB
      DO I=1,ISUB
         lonsub(i,j)=lon(IMIN+I-1,JMIN+J-1)
         latsub(i,j)=lat(IMIN+I-1,JMIN+J-1)
      ENDDO
      ENDDO    

!!    read in global land-sea mask of NCEP atmospheric products
!!
      INQUIRE(FILE=TRIM(landmask),EXIST=FEXIST)
      IF(FEXIST) THEN
        OPEN(81,file=trim(landmask))
        write(6,*) 'Read in landmask file  ', landmask
        READ(81,*)
        DO J=1,JM
        DO I=1,IM
           READ(81,*)x,y,value
           tmp1(i,j)=value
        ENDDO
        ENDDO
        DO J=1,JSUB
        DO I=1,ISUB
            landsub(i,j)=1-tmp1(IMIN+I-1,JMIN+J-1) !met landmask 1:land
        ENDDO
        ENDDO
      ELSE
          landsub=1  !use all data points (1 for water cells)
      ENDIF

      ALLOCATE(maskm_e(ISUB+2,JSUB+2))
      ALLOCATE(IFILL(ISUB,JSUB))
      ALLOCATE(JFILL(ISUB,JSUB))
      ALLOCATE(ISHORE(ISUB*JSUB/50))
      ALLOCATE(JSHORE(ISUB*JSUB/50))
      DO J=1,JSUB
      DO I=1,ISUB
         maskm_e(I+1,J+1)=landsub(I,J)
         IFILL(I,J)=I
         JFILL(I,J)=J
      ENDDO
      ENDDO
      DO I=2,ISUB+1
           maskm_e(I,1)=maskm_e(I,2)
           maskm_e(I,JSUB+2)=maskm_e(I,JSUB+1)
      ENDDO
      DO J=1,JSUB+2
           maskm_e(1,J)=maskm_e(2,J)
           maskm_e(ISUB+2,J)=maskm_e(ISUB+1,J)
      ENDDO
       NSHORE=0
       DO J=2,JSUB+1
       DO I=2,ISUB+1
           s=maskm_e(I-1,J-1)+maskm_e(I,J-1)+maskm_e(I+1,J-1)
     &      +maskm_e(I-1,J  )+maskm_e(I,J  )+maskm_e(I+1,J  )
     &      +maskm_e(I-1,J+1)+maskm_e(I,J+1)+maskm_e(I+1,J+1)
           if (maskm_e (I,J) .GT. 0.5 .AND. s .LT. 9 ) then 
              NSHORE=NSHORE+1
              ISHORE(NSHORE)=I-1
              JSHORE(NSHORE)=J-1
           endif
       ENDDO
       ENDDO
       open(45,file='ShorePoints.dat')
       DO I=1,NSHORE
         write(45,*) ISHORE(I),JSHORE(I)
       ENDDO

       DO J=1,JSUB  ! find nearest coastal point for all land cells
       DO I=1,ISUB
          IF (landsub(I,J) .LT. 0.5) THEN
           DISTMIN=1.0E20
           DO N1=1,NSHORE
              DIST=(lonm(ISHORE(N1),JSHORE(N1))-lonm(I,J))**2
     &            +(latm(ISHORE(N1),JSHORE(N1))-latm(I,J))**2
              IF (DIST < DISTMIN) THEN
                 DISTMIN=DIST
                 NS=N1
              ENDIF
           ENDDO
           IFILL(I,J)=ISHORE(NS)
           JFILL(I,J)=JSHORE(NS)
           write(45,*) I, J, ISHORE(NS), JSHORE(NS)
         ENDIF
      ENDDO
      ENDDO
      close(45)
      write(6,*) "Finish finding nearest coast point!"

      allocate(XINP(NNSUB) )
      allocate(YINP(NNSUB) )
      allocate(ZINP(NNSUB) )
      allocate(XOUT(NNMODEL) )
      allocate(YOUT(NNMODEL) )
      allocate(ZOUT(NNMODEL ) )
      
      CALL TWO2ONED(XINP,lonsub,ISUB,JSUB)
      CALL TWO2ONED(YINP,latsub,ISUB,JSUB)
      CALL TWO2ONED(XOUT,lonm,IROMS,JROMS)
      CALL TWO2ONED(YOUT,latm,IROMS,JROMS)
c  perturb input data locations by adding random noise so that the interpolated points are 
C  unlikely to exactly coincide wit ha data point or lie on a line between data points, and 
C  also to avoid first three nodes fall in a straight line for the regular grid such as GFS, 
C  WOA05,etc. Otherwise, remesh routine fails.
c
c  max perturbation = 0.05 * grid size
      delx=0.00001
      dely=0.00001
      do i=1,NNSUB
         call random(r)
         XINP(i)=XINP(i)+delx*(0.5-r)
         call random(r)
         YINP(i)=YINP(i)+dely*(0.5-r)
      enddo
      IF (IGRD .EQ. 1)THEN
         write(*,*)'COMPUTING WEIGHTS AND WEIGHTNODES FOR REMESH !!!'
         call INTERP_REMESH(NNSUB,XINP,YINP,ZINP,
     *        NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,0)
      ELSEIF(IGRD .EQ. 2 .or. IGRD .EQ. 3 )THEN
         IF(trim(OCEAN_MODEL) .eq. 'FVCOM' 
     & 	 .or. trim(OCEAN_MODEL) .eq. 'SELFE')THEN
	   WRITE(*,*)'The Option of IGRD=',IGRD 
	   WRITE(*,*)'is not available for ',TRIM(OFS)
	   WRITE(*,*)'Please select IGRD=1 or IGRD=4'
	   STOP
	 ENDIF   
      ENDIF       
      pair_L=0.
      Uwind_L=0.
      Vwind_L=0.
      Tair_L=0.
      qair_L=0.
      rh_L=0.
      dlwrf_L=0.
      dswrf_L=0.
      ulwrf_L=0.
      uswrf_L=0.
      prate_L=0.0
      spfh_L=0.0
      lhtfl_L=0.0
      shtflm_L=0.0
      nflux_L=0.0
      netlwrf_L=0.0
      netswrf_L=0.0
      tdair_L=0.0
      tcdc_L=0.0
      evp_L=0.0
      FNAME='PRMSL.'//trim(DBASE)
      INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
      IF(FEXIST)pair_L =1.
      FNAME='UGRD.'//trim(DBASE)
      INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
      IF(FEXIST)Uwind_L = 1.
      FNAME='VGRD.'//trim(DBASE)
      INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
      IF(FEXIST)Vwind_L = 1.
      FNAME='TMP.'//trim(DBASE)
      INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
      IF(FEXIST)tair_L = 1.
      FNAME='PRATE.'//trim(DBASE)
      INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
      IF(FEXIST)prate_L = 1.
      FNAME='SPFH.'//trim(DBASE)
      INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
      IF(FEXIST)spfh_L = 1.
      FNAME='DPT.'//trim(DBASE)
      INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
      IF(FEXIST)tdair_L = 1.
      FNAME='TCDC.'//trim(DBASE)
      INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
      IF(FEXIST)tcdc_L = 1.
      FNAME='EVP.'//trim(DBASE)
      INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
      IF(FEXIST)evp_L = 1.

      FNAME='RH.'//trim(DBASE)
      INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
      IF(FEXIST)THEN
        qair_L = 1.
      ELSE 	
        FNAME='DPT.'//trim(DBASE)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
        IF((FEXIST) .AND. (tair_L .GT. 0.0))qair_L = 1.
      ENDIF
      IF(trim(DBASE) .NE. "RUC" )THEN
        FNAME='DLWRF.'//trim(DBASE)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
        IF(FEXIST)dlwrf_L = 1.
        FNAME='DSWRF.'//trim(DBASE)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
        IF(FEXIST)dswrf_L = 1.
        FNAME='ULWRF.'//trim(DBASE)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
        IF(FEXIST)ulwrf_L = 1.
        FNAME='USWRF.'//trim(DBASE)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
        IF(FEXIST)uswrf_L = 1.
        FNAME='LHTFL.'//trim(DBASE)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
        IF(FEXIST)lhtfl_L = 1.
        FNAME='SHTFL.'//trim(DBASE)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
        IF(FEXIST)shtfl_L = 1.
	IF( dlwrf_L .GT. 0.0 .AND. ulwrf_L .GT. 0.0)netlwrf_L = 1.
	IF( dswrf_L .GT. 0.0 .AND. uswrf_L .GT. 0.0)netswrf_L = 1.
      ELSEIF( trim(DBASE) .EQ. "RUC" )THEN
        FNAME='NLWRS.'//trim(DBASE)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
        IF(FEXIST)netlwrf_L = 1.
        FNAME='NSWRS.'//trim(DBASE)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
        IF(FEXIST)netswrf_L = 1.
      ENDIF
      IF (trim(DBASE) .EQ. "NDFD" )THEN
        FNAME='WIND.'//trim(DBASE)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
        IF(FEXIST)Uwind_L = 1.
        FNAME='WDIR.'//trim(DBASE)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
        IF(FEXIST)Vwind_L = 1.
!        FNAME='TCDC.'//trim(DBASE)
!        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST)
!        IF(FEXIST)tcdc_L = 1.
      ENDIF
      IF( netlwrf_Ld .GT. 0.0 .AND. netswrf_L .GT. 0.0 .AND.
     1    lhtfl_L .GT. 0.0 .AND. shtfl_L .GT. 0.0 )nflux_L = 1.
      	
      ITMP=pair_L+Uwind_L+Vwind_L+Tair_L+qair_L+dlwrf_L+dswrf_L	
      IF(ITMP .LE. 0)THEN
        WRITE(*,*)'No '//trim(DBASE)//'atmospheric variable available'
	 WRITE(*,*)'Check surface forcing products'
	 WRITE(*,*)'generating surface forcing stop in 
     1	 nos_ofs_create_forcing_met.f'
	 STOP
      ENDIF	  
      IF (IGRD .GT. 0)THEN
	   call write_netCDF_surfaceforcing_ROMS(OUTPUTFILE,ncid,1,
     &     IGRD,IROMS,JROMS,base_date,lonm,latm,time_start,uwind_L,
     &     vwind_L,pair_L,tair_L,qair_L,netswrf_L,dlwrf_L,
     &     prate_L,tcdc_L,evp_L,globalstr)
      ELSE
	   call write_netCDF_surfaceforcing_ROMS(OUTPUTFILE,ncid,1,
     &     IGRD,ISUB,JSUB,base_date,lonsub,latsub,time_start,uwind_L,
     &     vwind_L,pair_L,tair_L,qair_L,netswrf_L,dlwrf_L,
     &     prate_L,tcdc_L,evp_L,globalstr)

      ENDIF

      ncount=0
      NLEN=24
!      if(trim(DBASE) .EQ. "RTMA" .or. trim(DBASE) .EQ. "RUC")NLEN=24
! FILE UNITS from 81-95 are used for input files
      CLOSE(81)  ! for PRMSL  Pressure reduced to MSL (Pa)
      CLOSE(82)  ! for TMP    Temperature (K)
      CLOSE(83)  ! for RH     Relative Humility (%)
      CLOSE(84)  ! for UGRD/WIND   u-component of wind (m/s), WIND is wind speed
      CLOSE(85)  ! for VGRD/WDIR   v-component of wind (m/s),WDIR is wind dir.
!                (degree true)
      CLOSE(86)  ! for ULWRF - upward long wave radiation flux
      CLOSE(87)  ! for DLWRF - downward long wave radiation flux
      CLOSE(88)  ! for DSWRF - downward short wave radiation flux
      CLOSE(89)  ! for DPT    Dew Point Temperature (K)
      CLOSE(90)  ! for USWRF - Upward short wave radiation flux (W/m2)
      CLOSE(91)  ! for LHTFL - Latent heat net flux (W/m2)
      CLOSE(92)  ! for SHTFL - Sensible heat net flux (W/m2)
      CLOSE(93)  ! for PRATE Precipitation rate (kg/m2/s)
      CLOSE(94)  ! for SPFH  Specific humility (kg/kg)
      CLOSE(95)  ! for TCDC  Total cloud cover (%)
      CLOSE(96)  ! for EVP  Total evaparation (kg/m2)
!                  APCP Total precipitation (kg/m2)
!                  NLWRS - Net surface short-wave radiation flux (W/m2)
!                  NLWRS - Net surface long-wave radiation flux (W/m2)

      DO N=1,9999  !!NLEN  !! loop from hour 00 to forecast hour 60 (NAM forecast goes to 84 hours for each cycle)
	TIME=-9999.0
        FNAME='PRMSL.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
	IF(FEXIST .and. (.NOT. FOPEN))OPEN(81,file=trim(FNAME))
        IF(.NOT.FEXIST)THEN
            DO J=1,JSUB
	    DO I=1,ISUB
             pair(i,j)=-99999.9 
	    ENDDO
	    ENDDO
        ELSE
	  READ(81,'(a)',end=99)BUFFER
          IND=INDEX(BUFFER,'d=')
	  IF(IND .LE. 0)THEN
	     WRITE(*,*)'record does not include time info in '
	     STOP 'error in PRMSL'
	  ENDIF   
	  IND_DATE=IND+2
	  IND_HOUR=IND+12
          IND_HOUR_END=INDEX(BUFFER,'hour')-1
          IND=INDEX(BUFFER,'-',BACK=.TRUE.)
          IF(IND .GT. 0)IND_HOUR=IND+1
!          IF(IND .GT. 0)IND_HOUR_END=IND-1
!	  IF(BUFFER(IND_HOUR:IND_HOUR) .EQ. '-')IND_HOUR=IND_HOUR+1
	  READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
          IND=INDEX(BUFFER,'anl')
	  IF(IND .GT. 0)THEN
	     IHH=00
	  ELSE
	     READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
	  ENDIF   
          yearb=IYR
          monthb=IMM
          dayb=IDD
          hourb=IHH+ICYC
          time=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
          DO J=1,JM
	  DO I=1,IM
	     READ(81,*,end=99)x,y,value
             tmp1(i,j)=value 
          ENDDO
	  ENDDO
          DO J=1,JSUB
	  DO I=1,ISUB
            pair(i,j)=tmp1(IMIN+I-1,JMIN+J-1)/100.0 !convert to milibar
	  ENDDO
	  ENDDO    
	ENDIF
        print *,'IYRIMMIDDICYCIHH=',IYR,IMM,IDD,ICYC,IHH
        FNAME='TMP.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
	IF(FEXIST .and. (.NOT. FOPEN))OPEN(82,file=trim(FNAME))
        IF(.NOT.FEXIST)THEN
!           WRITE(*,*)'The first file PRMSL.'//trim(DBASE)//' does not exist'
            DO J=1,JSUB
	    DO I=1,ISUB
             tair(i,j)=-99999.9 
	    ENDDO
	    ENDDO
        ELSE
	  READ(82,'(a)',end=99)BUFFER
          IND=INDEX(BUFFER,'d=')
	  IF(IND .LE. 0)THEN
	     WRITE(*,*)'record does not include time info'
	     STOP 'error in TMP'
	  ENDIF   
	  IND_DATE=IND+2
          IND_HOUR=IND+12
          IND_HOUR_END=INDEX(BUFFER,'hour')-1
          IND=INDEX(BUFFER,'-',BACK=.TRUE.)
          IF(IND .GT. 0)IND_HOUR=IND+1
 !         IF(IND .GT. 0)IND_HOUR_END=IND-1
!          print *,'test=',IND_DATE,IND_HOUR,IND_HOUR_END,
!     1    BUFFER(IND_HOUR:IND_HOUR_END)
	  READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
!          print *,'IYRIMMIDDICYCIHH=',IYR,IMM,IDD,ICYC,
!     1   BUFFER(IND_DATE:IND_DATE+9)
          IND=INDEX(BUFFER,'anl')
	  IF(IND .GT. 0)THEN
	     IHH=00
	  ELSE
	     READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
	  ENDIF   
          yearb=IYR
          monthb=IMM
          dayb=IDD
          hourb=ihh+ICYC
          time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
	  if(time .lt. 0.0)time=time0
	  IF(time0 .GE. time)THEN
            DO J=1,JM
	    DO I=1,IM
	      READ(82,*)x,y,value
              tmp1(i,j)=value 
            ENDDO
	    ENDDO
            DO J=1,JSUB
	    DO I=1,ISUB
             tair(i,j)=tmp1(IMIN+I-1,JMIN+J-1)-273.15 
	    ENDDO
	    ENDDO
	  ELSE
	    BACKSPACE (82)
            DO J=1,JSUB
	    DO I=1,ISUB
             tair(i,j)=-99999.9 
	    ENDDO
	    ENDDO
	  ENDIF
	ENDIF  
        print *,'IYRIMMIDDICYCIHH=',IYR,IMM,IDD,ICYC,IHH
        FNAME='TCDC.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
        IF(FEXIST .and. (.NOT. FOPEN))OPEN(95,file=trim(FNAME))
        IF(.NOT.FEXIST)THEN
          WRITE(*,*)'The file TCDC.'//trim(DBASE)//' does not exist'
           DO J=1,JSUB
           DO I=1,ISUB
             tcdc(i,j)=-99999.9
           ENDDO
           ENDDO
        ELSE
          READ(95,'(a120)',end=2300)BUFFER
          IND=INDEX(BUFFER,'d=')
          IF(IND .LE. 0)THEN
            WRITE(*,*)'record does not include time info'
            WRITE(*,*)'buffer=',trim(buffer)
            STOP 'error in TCDC'
          ENDIF
          IND_DATE=IND+2
          IND_HOUR=IND+12
          IND_HOUR_END=INDEX(BUFFER,'hour')-1
          IND=INDEX(BUFFER,'-',BACK=.TRUE.)
!          IF(IND .GT. 0)IND_HOUR_END=IND-1
          IF(IND .GT. 0)IND_HOUR=IND+1
          READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
          IND=INDEX(BUFFER,'anl')
          IF(IND .GT. 0)THEN
             IHH=00
          ELSE
             READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
          ENDIF
          print *,'IYRIMMIDDICYCIHH=',IYR,IMM,IDD,ICYC,IHH
          yearb=IYR
          monthb=IMM
          dayb=IDD
          hourb=ihh+ICYC
          time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
          if(time .lt. 0.0)then
            time=time0
            jday0=JULIAN(yearb,monthb,dayb,hourb)
          endif
          IF(time0 .GE. time)THEN
            DO J=1,JM
            DO I=1,IM
              READ(95,*)x,y,value
              tmp1(i,j)=value
            ENDDO
            ENDDO
            DO J=1,JSUB
            DO I=1,ISUB
              tcdc(i,j)=tmp1(IMIN+I-1,JMIN+J-1)
            ENDDO
            ENDDO
          ENDIF
        ENDIF
2300    continue
        FNAME='DPT.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
        IF(FEXIST .and. (.NOT. FOPEN))OPEN(89,file=trim(FNAME))
        IF(.NOT.FEXIST)THEN
!          WRITE(*,*)'The first file TDAIR.'//trim(DBASE)//' does not exist'
           DO J=1,JSUB
           DO I=1,ISUB
             tdair(i,j)=-99999.9
           ENDDO
           ENDDO
        ELSE
          READ(89,'(a)',end=2302)BUFFER
          IND=INDEX(BUFFER,'d=')
          IF(IND .LE. 0)THEN
            WRITE(*,*)'record does not include time info'
            STOP'error in DPT'
          ENDIF
          IND_DATE=IND+2
          IND_HOUR=IND+12
          IND_HOUR_END=INDEX(BUFFER,'hour')-1
          IND=INDEX(BUFFER,'-',BACK=.TRUE.)
          IF(IND .GT. 0)IND_HOUR=IND+1
 !         IF(IND .GT. 0)IND_HOUR_END=IND-1
 !         print *,'test=',IND_DATE,IND_HOUR,IND_HOUR_END,
 !    1    BUFFER(IND_HOUR:IND_HOUR_END)
          READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
!          print *,'IYRIMMIDDICYCIHH=',IYR,IMM,IDD,ICYC,
!     1    BUFFER(IND_DATE:IND_DATE+9)
          IND=INDEX(BUFFER,'anl')
          IF(IND .GT. 0)THEN
             IHH=00
          ELSE
             READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
          ENDIF
          print *,'IYRIMMIDDICYCIHH=',IYR,IMM,IDD,ICYC,IHH
          yearb=IYR
          monthb=IMM
          dayb=IDD
          hourb=ihh+ICYC
          time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
          if(time .lt. 0.0)then
            time=time0
            jday0=JULIAN(yearb,monthb,dayb,hourb)
          endif
          IF(time0 .GE. time)THEN
            DO J=1,JM
            DO I=1,IM
              READ(89,*)x,y,value
              tmp1(i,j)=value
            ENDDO
            ENDDO
            DO J=1,JSUB
            DO I=1,ISUB
              tdair(i,j)=tmp1(IMIN+I-1,JMIN+J-1)
              if (tmp1(IMIN+I-1,JMIN+J-1) .GT. -999.0)then
                 tdair(i,j)=tmp1(IMIN+I-1,JMIN+J-1)-273.15
              endif
            ENDDO
            ENDDO
          ENDIF
        ENDIF
2302    continue


        FNAME='RH.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
	IF(FEXIST .and. (.NOT. FOPEN))OPEN(83,file=trim(FNAME))
        IF(FEXIST)THEN
	  READ(83,'(a)',end=2304)BUFFER
          IND=INDEX(BUFFER,'d=')
	  IF(IND .LE. 0)THEN
	     WRITE(*,*)'record does not include time info'
	     STOP
	  ENDIF   
	  IND_DATE=IND+2
          IND_HOUR=IND+12
          IND_HOUR_END=INDEX(BUFFER,'hour')-1
          IND=INDEX(BUFFER,'-',BACK=.TRUE.)
!          IF(IND .GT. 0)IND_HOUR_END=IND-1
          IF(IND .GT. 0)IND_HOUR=IND+1
	  READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
          IND=INDEX(BUFFER,'anl')
	  IF(IND .GT. 0)THEN
	     IHH=00
	  ELSE
	     READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
	  ENDIF   
          yearb=IYR
          monthb=IMM
          dayb=IDD
          hourb=ihh+ICYC
          time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
	  if(time .lt. 0.0)time=time0
          IF(time0 .GE. time)THEN
 !	  IF(abs(time0-time) .LE. 0.01)THEN
            DO J=1,JM
	    DO I=1,IM
	      READ(83,*)x,y,value
              tmp1(i,j)=value 
            ENDDO
	    ENDDO
            DO J=1,JSUB
	    DO I=1,ISUB
               qair(i,j)=tmp1(IMIN+I-1,JMIN+J-1)
	       if(qair(i,j).lt. 2.0)qair(i,j)=2.0      !! per Lyon's request  06/16/2009
	       if(qair(i,j).gt. 99.0)qair(i,j)=99.0
	    ENDDO
	    ENDDO    
	  ELSE
	    BACKSPACE (83)
            DO J=1,JSUB
	    DO I=1,ISUB
             qair(i,j)=-99999.9 
	    ENDDO
	    ENDDO
          ENDIF
        ELSE
C  calculate relative humility from dew point temperature according to formulas from http://www.cactus2000.de
          FNAME='DPT.'//trim(DBASE)
          WRITE(*,*)'READING ',TRIM(FNAME)
          INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
          IF(.NOT.FEXIST)THEN
              a0=6.107799961
              a1=4.436518521*0.1
              a2=1.428945805*0.001
              a3=2.650648471*10.0**(-4)
              a4=3.031240396*10.0**(-6)
              DO J=1,JSUB
              DO I=1,ISUB
                 e=a0+tdair(i,j)*(a1+ tdair(i,j)*
     &                        (a2+(tdair(i,j)*
     &                        (a3+tdair(i,j)*a4) ) ))
                 es=a0+tair(i,j)*(a1+ tair(i,j)*
     &                        (a2+(tair(i,j)*
     &                        (a3+tair(i,j)*a4) ) ))
                 if (abs(es) .gt. 0.0001)then
                   tmp1(i,j)=e/es*100.0
                 else
                   tmp1(i,j)=-99999.9
                 endif
                 if(tmp1(i,j).lt. 2.0)tmp1(i,j)=2.0      !! per Lyon's request
                 if(tmp1(i,j).gt. 99.0)tmp1(i,j)=99.0
              ENDDO
              ENDDO
          ELSE
              DO J=1,JSUB
              DO I=1,ISUB
                 tmp1(i,j)=-99999.9
              ENDDO
              ENDDO
          ENDIF
          DO J=1,JSUB
          DO I=1,ISUB
             qair(i,j)=tmp1(i,j)
          ENDDO
          ENDDO

        ENDIF
2304    continue

         print *,'IYRIMMIDDICYCIHH=',IYR,IMM,IDD,ICYC,IHH
        FNAME='UGRD.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
        IF (trim(DBASE) .EQ. "NDFD" )FNAME='WIND.'//trim(DBASE)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
	IF(FEXIST .and. (.NOT. FOPEN))OPEN(84,file=trim(FNAME))
        IF(.NOT.FEXIST)THEN
            DO J=1,JSUB
	    DO I=1,ISUB
             uwind(i,j)=-99999.9 
	    ENDDO
	    ENDDO
        ELSE
	    READ(84,'(a)',end=2306)BUFFER
            IND=INDEX(BUFFER,'d=')
	    IF(IND .LE. 0)THEN
	      WRITE(*,*)'record does not include time info'
	      STOP 
	    ENDIF   
	    IND_DATE=IND+2
            IND_HOUR=IND+12
            IND_HOUR_END=INDEX(BUFFER,'hour')-1
            IND=INDEX(BUFFER,'-',BACK=.TRUE.)
!            IF(IND .GT. 0)IND_HOUR_END=IND-1
          IF(IND .GT. 0)IND_HOUR=IND+1

	    READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
            IND=INDEX(BUFFER,'anl')
	    IF(IND .GT. 0)THEN
	      IHH=00
	    ELSE
	      READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
	    ENDIF   
            yearb=IYR
            monthb=IMM
            dayb=IDD
            hourb=ihh+ICYC
            time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
	  if(time .lt. 0.0)time=time0
	  IF(time0 .GE. time)THEN
            DO J=1,JM
	    DO I=1,IM
	      READ(84,*)x,y,value
              tmp1(i,j)=value !convert to milibar
            ENDDO
	    ENDDO
            DO J=1,JSUB
	    DO I=1,ISUB
             uwind(i,j)=tmp1(IMIN+I-1,JMIN+J-1) 
	    ENDDO
	    ENDDO    
	  ELSE
	    BACKSPACE (84)
            DO J=1,JSUB
	    DO I=1,ISUB
             uwind(i,j)=-99999.9 
	    ENDDO
	    ENDDO
          ENDIF
	ENDIF  
2306    continue

        print *,'IYRIMMIDDICYCIHH=',IYR,IMM,IDD,ICYC,IHH
        FNAME='VGRD.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
        IF (trim(DBASE) .EQ. "NDFD" )FNAME='WDIR.'//trim(DBASE)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
	IF(FEXIST .and. (.NOT. FOPEN))OPEN(85,file=trim(FNAME))
        IF(.NOT.FEXIST)THEN
            DO J=1,JSUB
	    DO I=1,ISUB
             vwind(i,j)=-99999.9 
	    ENDDO
	    ENDDO
        ELSE
	    READ(85,'(a)',end=2308)BUFFER
            IND=INDEX(BUFFER,'d=')
	    IF(IND .LE. 0)THEN
	      WRITE(*,*)'record does not include time info'
	      STOP
	    ENDIF   
	    IND_DATE=IND+2
            IND_HOUR=IND+12
            IND_HOUR_END=INDEX(BUFFER,'hour')-1
            IND=INDEX(BUFFER,'-',BACK=.TRUE.)
 !           IF(IND .GT. 0)IND_HOUR_END=IND-1
          IF(IND .GT. 0)IND_HOUR=IND+1

	    READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
            IND=INDEX(BUFFER,'anl')
	    IF(IND .GT. 0)THEN
	      IHH=00
	    ELSE
	      READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
	    ENDIF   
            yearb=IYR
            monthb=IMM
            dayb=IDD
            hourb=ihh+ICYC
            time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
	  if(time .lt. 0.0)time=time0
	  IF(time0 .GE. time)THEN
            DO J=1,JM
	    DO I=1,IM
	      READ(85,*)x,y,value
              tmp1(i,j)=value 
            ENDDO
	    ENDDO
            DO J=1,JSUB
	    DO I=1,ISUB
             vwind(i,j)=tmp1(IMIN+I-1,JMIN+J-1) 
	    ENDDO
	    ENDDO    
	  ELSE
	    BACKSPACE (85)
            DO J=1,JSUB
	    DO I=1,ISUB
             vwind(i,j)=-99999.9 
	    ENDDO
	    ENDDO
          ENDIF
	ENDIF 
2308    continue

        IF(trim(DBASE) .EQ. "NDFD")THEN   ! uwind=WIND SPEED and vwind=WIND DIR
! DIRmet is the wind direction with respect to true north (0=north, 90=east,
! 180=south, 270=west) that the wind is coming from                      
            DO J=1,JSUB
            DO I=1,ISUB
             if (uwind(i,j) .GE. 0.0)then
               tmp_u=-uwind(i,j)*sin(vwind(i,j)*0.01745329) !! pi/180=0.01745329
               tmp_v=-uwind(i,j)*cos(vwind(i,j)*0.01745329)
               uwind(i,j)=tmp_u
               vwind(i,j)=tmp_v
             else
               uwind(i,j)=-99999.9
               vwind(i,j)=-99999.9
             endif
            ENDDO
            ENDDO

        ENDIF
        print *,'IYRIMMIDDICYCIHH=',IYR,IMM,IDD,ICYC,IHH
         
	IF(trim(DBASE) .EQ. "RUC")GOTO 400 !! read in Net heat flux
        FNAME='ULWRF.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
	IF(FEXIST .and. (.NOT. FOPEN))OPEN(86,file=trim(FNAME))
        IF(.NOT.FEXIST)THEN
            DO J=1,JSUB
	    DO I=1,ISUB
             ulwrf(i,j)=-99999.9 
	    ENDDO
	    ENDDO
        ELSE
	    READ(86,'(a)',end=2310)BUFFER
            IND=INDEX(BUFFER,'d=')
	    IF(IND .LE. 0)THEN
	      WRITE(*,*)'record does not include time info'
	      STOP
	    ENDIF   
	    IND_DATE=IND+2
            IND_HOUR=IND+12
            IND_HOUR_END=INDEX(BUFFER,'hour')-1
            IND=INDEX(BUFFER,'-',BACK=.TRUE.)
!            IF(IND .GT. 0)IND_HOUR_END=IND-1
          IF(IND .GT. 0)IND_HOUR=IND+1

            
	    READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
            IND=INDEX(BUFFER,'anl')
	    IF(IND .GT. 0)THEN
	      IHH=00
	    ELSE
	      READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
	    ENDIF   
            yearb=IYR
            monthb=IMM
            dayb=IDD
            hourb=ihh+ICYC
            time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
            print *,'IYRIMMIDDICYCIHH=',IYR,IMM,IDD,ICYC,IHH
	  if(time .lt. 0.0)time=time0
	  IF(time0 .GE.time)THEN
            DO J=1,JM
	    DO I=1,IM
	      READ(86,*)x,y,value
              tmp1(i,j)=value 
            ENDDO
	    ENDDO
            DO J=1,JSUB
	    DO I=1,ISUB
             ulwrf(i,j)=tmp1(IMIN+I-1,JMIN+J-1)*SCALE_HFLUX
	    ENDDO
	    ENDDO    
	  ELSE
	    BACKSPACE (86)
            DO J=1,JSUB
	    DO I=1,ISUB
             ulwrf(i,j)=-99999.9 
	    ENDDO
	    ENDDO
          ENDIF
	ENDIF
2310    continue 
!	CLOSE(86) 
        FNAME='DLWRF.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
	IF(FEXIST .and. (.NOT. FOPEN))OPEN(87,file=trim(FNAME))
        IF(.NOT.FEXIST)THEN
            DO J=1,JSUB
	    DO I=1,ISUB
             dlwrf(i,j)=-99999.9 
	    ENDDO
	    ENDDO
        ELSE
	    READ(87,'(a)',end=2312)BUFFER
            IND=INDEX(BUFFER,'d=')
	    IF(IND .LE. 0)THEN
	      WRITE(*,*)'record does not include time info'
	      STOP
	    ENDIF   
	    IND_DATE=IND+2
            IND_HOUR=IND+12
            IND_HOUR_END=INDEX(BUFFER,'hour')-1
            IND=INDEX(BUFFER,'-',BACK=.TRUE.)
!            IF(IND .GT. 0)IND_HOUR_END=IND-1
          IF(IND .GT. 0)IND_HOUR=IND+1

!	  IF(BUFFER(IND_HOUR:IND_HOUR) .EQ. '-')IND_HOUR=IND_HOUR+1
	    READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
            IND=INDEX(BUFFER,'anl')
	    IF(IND .GT. 0)THEN
	      IHH=00
	    ELSE
	      READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
	    ENDIF   
            yearb=IYR
            monthb=IMM
            dayb=IDD
            hourb=ihh+ICYC
            time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
	  if(time .lt. 0.0)time=time0
!          IF( (abs(time0-time) .LE. 0.01)
!     1      .or. (time0 .lt. time-0.0002) )THEN
            if (time0 .GE. time)then
            DO J=1,JM
            DO I=1,IM
              READ(87,*)x,y,value
              tmp1(i,j)=value
            ENDDO
            ENDDO
            DO J=1,JSUB
            DO I=1,ISUB
!              dlwrf(i,j)=tmp1(IMIN+I-1,JMIN+J-1)*SCALE_HFLUX-tmp2(I,J)
              dlwrf(i,j)=tmp1(IMIN+I-1,JMIN+J-1)*SCALE_HFLUX
            ENDDO
            ENDDO
    
	  ELSE
	    BACKSPACE (87)
            DO J=1,JSUB
	    DO I=1,ISUB
             dlwrf(i,j)=-99999.9 
	    ENDDO
	    ENDDO
          ENDIF
	ENDIF  
2312    continue
!	CLOSE(88) 
        FNAME='DSWRF.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
	IF(FEXIST .and. (.NOT. FOPEN))OPEN(88,file=trim(FNAME))
        IF(.NOT.FEXIST)THEN
            DO J=1,JSUB
	    DO I=1,ISUB
             dswrf(i,j)=-99999.9 
	    ENDDO
	    ENDDO
        ELSE
	    READ(88,'(a)',end=2314)BUFFER
            IND=INDEX(BUFFER,'d=')
	    IF(IND .LE. 0)THEN
	      WRITE(*,*)'record does not include time info'
	      STOP
	    ENDIF   
	    IND_DATE=IND+2
            IND_HOUR=IND+12
            IND_HOUR_END=INDEX(BUFFER,'hour')-1
            IND=INDEX(BUFFER,'-',BACK=.TRUE.)
!            IF(IND .GT. 0)IND_HOUR_END=IND-1
         IF(IND .GT. 0)IND_HOUR=IND+1

!	  IF(BUFFER(IND_HOUR:IND_HOUR) .EQ. '-')IND_HOUR=IND_HOUR+1
	    READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
            IND=INDEX(BUFFER,'anl')
	    IF(IND .GT. 0)THEN
	      IHH=00
	    ELSE
	      READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
	    ENDIF   
            yearb=IYR
            monthb=IMM
            dayb=IDD
            hourb=ihh+ICYC
            time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
	  if(time .lt. 0.0)time=time0
!          IF( (abs(time0-time) .LE. 0.01)
!     1      .or. (time0 .lt. time-0.0002) )THEN

	  IF(time0 .GE. time)THEN
            DO J=1,JM
	    DO I=1,IM
	      READ(88,*)x,y,value
              tmp1(i,j)=value !convert to milibar
            ENDDO
	    ENDDO
            DO J=1,JSUB
	    DO I=1,ISUB
             DSWRF(i,j)=tmp1(IMIN+I-1,JMIN+J-1)*SCALE_HFLUX 
	    ENDDO
	    ENDDO    
	  ELSE
	    BACKSPACE (88)
            DO J=1,JSUB
	    DO I=1,ISUB
             DSWRF(i,j)=-99999.9 
	    ENDDO
	    ENDDO
          ENDIF
	ENDIF  
2314    continue

        FNAME='USWRF.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
	IF(FEXIST .and. (.NOT. FOPEN))OPEN(90,file=trim(FNAME))
        IF(.NOT.FEXIST)THEN
            DO J=1,JSUB
	    DO I=1,ISUB
             uswrf(i,j)=-99999.9 
	    ENDDO
	    ENDDO
        ELSE
	    READ(90,'(a)',end=2316)BUFFER
            IND=INDEX(BUFFER,'d=')
	    IF(IND .LE. 0)THEN
	      WRITE(*,*)'record does not include time info'
	      STOP
	    ENDIF   
	    IND_DATE=IND+2
            IND_HOUR=IND+12
            IND_HOUR_END=INDEX(BUFFER,'hour')-1
            IND=INDEX(BUFFER,'-',BACK=.TRUE.)
 !           IF(IND .GT. 0)IND_HOUR_END=IND-1
         IF(IND .GT. 0)IND_HOUR=IND+1

	    READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
            IND=INDEX(BUFFER,'anl')
	    IF(IND .GT. 0)THEN
	      IHH=00
	    ELSE
	      READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
	    ENDIF   
            yearb=IYR
            monthb=IMM
            dayb=IDD
            hourb=ihh+ICYC
            time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
	  if(time .lt. 0.0)time=time0
	  IF(time0 .GE. time)THEN
 !         IF( (abs(time0-time) .LE. 0.01)
 !    1      .or. (time0 .lt. time-0.0002) )THEN

            DO J=1,JM
	    DO I=1,IM
	      READ(90,*)x,y,value
              tmp1(i,j)=value !convert to milibar
            ENDDO
	    ENDDO
            DO J=1,JSUB
	    DO I=1,ISUB
             uswrf(i,j)=tmp1(IMIN+I-1,JMIN+J-1)*SCALE_HFLUX !ading scaling factor ro reduce NAM HFLUX
	    ENDDO
	    ENDDO    
	  ELSE
	    BACKSPACE (90)
            DO J=1,JSUB
	    DO I=1,ISUB
             uswrf(i,j)=-99999.9 
	    ENDDO
	    ENDDO
          ENDIF
	ENDIF  
2316    CONTINUE
!        CLOSE(88)
        FNAME='LHTFL.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
	IF(FEXIST .and. (.NOT. FOPEN))OPEN(91,file=trim(FNAME))
        IF(.NOT.FEXIST)THEN
            DO J=1,JSUB
	    DO I=1,ISUB
             lhtfl(i,j)=-99999.9 
	    ENDDO
	    ENDDO
        ELSE
	    READ(91,'(a)',end=2318)BUFFER
            IND=INDEX(BUFFER,'d=')
	    IF(IND .LE. 0)THEN
	      WRITE(*,*)'record does not include time info'
	      STOP
	    ENDIF   
	    IND_DATE=IND+2
            IND_HOUR=IND+12
            IND_HOUR_END=INDEX(BUFFER,'hour')-1
            IND=INDEX(BUFFER,'-',BACK=.TRUE.)
!            IF(IND .GT. 0)IND_HOUR_END=IND-1
        IF(IND .GT. 0)IND_HOUR=IND+1

!	  IF(BUFFER(IND_HOUR:IND_HOUR) .EQ. '-')IND_HOUR=IND_HOUR+1
	    READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
            IND=INDEX(BUFFER,'anl')
	    IF(IND .GT. 0)THEN
	      IHH=00
	    ELSE
	      READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
	    ENDIF   
            yearb=IYR
            monthb=IMM
            dayb=IDD
            hourb=ihh+ICYC
            time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
	  if(time .lt. 0.0)time=time0
 !         IF( (abs(time0-time) .LE. 0.01)
 !    1      .or. (time0 .lt. time-0.0002) )THEN

	  IF(time0 .GE. time)THEN
            DO J=1,JM
	    DO I=1,IM
	      READ(91,*)x,y,value
              tmp1(i,j)=value 
            ENDDO
	    ENDDO
            DO J=1,JSUB
	    DO I=1,ISUB
             lhtfl(i,j)=tmp1(IMIN+I-1,JMIN+J-1)*SCALE_HFLUX 
	    ENDDO
	    ENDDO    
	  ELSE
	    BACKSPACE (91)
            DO J=1,JSUB
	    DO I=1,ISUB
             lhtfl(i,j)=-99999.9 
	    ENDDO
	    ENDDO
          ENDIF
	ENDIF  
2318    continue
!        CLOSE(88)
        FNAME='SHTFL.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
	IF(FEXIST .and. (.NOT. FOPEN))OPEN(92,file=trim(FNAME))
        IF(.NOT.FEXIST)THEN
            DO J=1,JSUB
	    DO I=1,ISUB
             shtfl(i,j)=-99999.9 
	    ENDDO
	    ENDDO
        ELSE
	    READ(92,'(a)',end=2320)BUFFER
            IND=INDEX(BUFFER,'d=')
	    IF(IND .LE. 0)THEN
	      WRITE(*,*)'record does not include time info'
	      STOP
	    ENDIF   
	    IND_DATE=IND+2
            IND_HOUR=IND+12
            IND_HOUR_END=INDEX(BUFFER,'hour')-1
            IND=INDEX(BUFFER,'-',BACK=.TRUE.)
!            IF(IND .GT. 0)IND_HOUR_END=IND-1
        IF(IND .GT. 0)IND_HOUR=IND+1

!	  IF(BUFFER(IND_HOUR:IND_HOUR) .EQ. '-')IND_HOUR=IND_HOUR+1
	    READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
            IND=INDEX(BUFFER,'anl')
	    IF(IND .GT. 0)THEN
	      IHH=00
	    ELSE
	      READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
	    ENDIF   
            yearb=IYR
            monthb=IMM
            dayb=IDD
            hourb=ihh+ICYC
            time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
	  if(time .lt. 0.0)time=time0
	  IF(time0 .GE. time)THEN
 !         IF( (abs(time0-time) .LE. 0.01)
 !    1      .or. (time0 .lt. time-0.0002) )THEN

            DO J=1,JM
	    DO I=1,IM
	      READ(92,*)x,y,value
              tmp1(i,j)=value 
            ENDDO
	    ENDDO
            DO J=1,JSUB
	    DO I=1,ISUB
             shtfl(i,j)=tmp1(IMIN+I-1,JMIN+J-1)*SCALE_HFLUX 
	    ENDDO
	    ENDDO    
	  ELSE
	    BACKSPACE (92)
            DO J=1,JSUB
	    DO I=1,ISUB
             shtfl(i,j)=-99999.9 
	    ENDDO
	    ENDDO
          ENDIF
	ENDIF  
2320    continue
        FNAME='PRATE.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
	IF(FEXIST .and. (.NOT. FOPEN))OPEN(93,file=trim(FNAME))
        IF(.NOT.FEXIST)THEN
            DO J=1,JSUB
	    DO I=1,ISUB
             PRATE(i,j)=-99999.9 
	    ENDDO
	    ENDDO
        ELSE
	    READ(93,'(a)',end=2322)BUFFER
            IND=INDEX(BUFFER,'d=')
	    IF(IND .LE. 0)THEN
	      WRITE(*,*)'record does not include time info'
	      STOP
	    ENDIF   
	    IND_DATE=IND+2
            IND_HOUR=IND+12
            IND_HOUR_END=INDEX(BUFFER,'hour')-1
            IND=INDEX(BUFFER,'-',BACK=.TRUE.)
            IF(IND .GT. 0)IND_HOUR=IND+1

!	  IF(BUFFER(IND_HOUR:IND_HOUR) .EQ. '-')IND_HOUR=IND_HOUR+1
	    READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
            IND=INDEX(BUFFER,'anl')
	    IF(IND .GT. 0)THEN
	      IHH=00
	    ELSE
	      READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
	    ENDIF   
            yearb=IYR
            monthb=IMM
            dayb=IDD
            hourb=ihh+ICYC
            time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
	  if(time .lt. 0.0)time=time0
 	  IF(time0 .GE. time)THEN
!          IF( (abs(time0-time) .LE. 0.01)
!     1      .or. (time0 .lt. time-0.0002) )THEN

            DO J=1,JM
	    DO I=1,IM
	      READ(93,*)x,y,value
              tmp1(i,j)=value !convert to milibar
            ENDDO
	    ENDDO
            DO J=1,JSUB
	    DO I=1,ISUB
             PRATE(i,j)=tmp1(IMIN+I-1,JMIN+J-1) 
	    ENDDO
	    ENDDO    
	  ELSE
	    BACKSPACE (93)
            DO J=1,JSUB
	    DO I=1,ISUB
             PRATE(i,j)=-99999.9 
	    ENDDO
	    ENDDO
          ENDIF
	ENDIF 
2322    continue	
	
        FNAME='SPFH.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
	IF(FEXIST .and. (.NOT. FOPEN))OPEN(94,file=trim(FNAME))
        IF(.NOT.FEXIST)THEN
            DO J=1,JSUB
	    DO I=1,ISUB
             SPFH(i,j)=-99999.9 
	    ENDDO
	    ENDDO
        ELSE
	    READ(94,'(a)',end=2324)BUFFER
            IND=INDEX(BUFFER,'d=')
	    IF(IND .LE. 0)THEN
	      WRITE(*,*)'record does not include time info'
	      STOP
	    ENDIF   
	    IND_DATE=IND+2
            IND_HOUR=IND+12
            IND_HOUR_END=INDEX(BUFFER,'hour')-1
            IND=INDEX(BUFFER,'-',BACK=.TRUE.)
            IF(IND .GT. 0)IND_HOUR=IND+1
	    READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
            IND=INDEX(BUFFER,'anl')
	    IF(IND .GT. 0)THEN
	      IHH=00
	    ELSE
	      READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
	    ENDIF   
            yearb=IYR
            monthb=IMM
            dayb=IDD
            hourb=ihh+ICYC
            time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
	  if(time .lt. 0.0)time=time0
	  IF(time0 .GE. time)THEN
!          IF( (abs(time0-time) .LE. 0.01)
!     1      .or. (time0 .lt. time-0.0002) )THEN

            DO J=1,JM
	    DO I=1,IM
	      READ(94,*)x,y,value
              tmp1(i,j)=value 
            ENDDO
	    ENDDO
            DO J=1,JSUB
	    DO I=1,ISUB
             SPFH(i,j)=tmp1(IMIN+I-1,JMIN+J-1)*SCALE_HFLUX 
	    ENDDO
	    ENDDO    
	  ELSE
	    BACKSPACE (94)
            DO J=1,JSUB
	    DO I=1,ISUB
             SPFH(i,j)=-99999.9 
	    ENDDO
	    ENDDO
          ENDIF
	ENDIF 
2324    continue	

        FNAME='EVP.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
        INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
	IF(FEXIST .and. (.NOT. FOPEN))OPEN(96,file=trim(FNAME))
        IF(.NOT.FEXIST)THEN
            DO J=1,JSUB
	    DO I=1,ISUB
             EVP(i,j)=-99999.9 
	    ENDDO
	    ENDDO
        ELSE
	    READ(96,'(a)',end=2326)BUFFER
            IND=INDEX(BUFFER,'d=')
	    IF(IND .LE. 0)THEN
	      WRITE(*,*)'record does not include time info'
	      STOP
	    ENDIF   
	    IND_DATE=IND+2
            IND_HOUR=IND+12
            IND_HOUR_END=INDEX(BUFFER,'hour')-1
            IND=INDEX(BUFFER,'-',BACK=.TRUE.)
            IF(IND .GT. 0)IND_HOUR=IND+1
	    READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
            IND=INDEX(BUFFER,'anl')
	    IF(IND .GT. 0)THEN
	      IHH=00
	    ELSE
	      READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
	    ENDIF   
            yearb=IYR
            monthb=IMM
            dayb=IDD
            hourb=ihh+ICYC
            time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
	  if(time .lt. 0.0)time=time0
          IF(time0 .GE.time)then
            DO J=1,JM
	    DO I=1,IM
	      READ(96,*)x,y,value
              tmp1(i,j)=value !convert to milibar
            ENDDO
	    ENDDO
            DO J=1,JSUB
	    DO I=1,ISUB
             EVP(i,j)=tmp1(IMIN+I-1,JMIN+J-1) 
	    ENDDO
	    ENDDO    
	  ELSE
	    BACKSPACE (96)
            DO J=1,JSUB
	    DO I=1,ISUB
             EVP(i,j)=-99999.9 
	    ENDDO
	    ENDDO
          ENDIF
	ENDIF 
2326    continue

	 
!! AJ sign convention of sensiable and latent heat flux for NAM and GFS is as, 
C  positive for upwards (out of ocean), and negative for downwards(into ocean)	

        IF(nflux_L .GT. 0.5)THEN
          DO J=1,JSUB
	  DO I=1,ISUB
            nflux(i,j)= dswrf(i,j)+dlwrf(i,j)-uswrf(i,j)-ulwrf(i,j)
     1                  -lhtfl(I,J)-shtfl(I,J)
	  ENDDO
	  ENDDO
	ELSE
            nflux(i,j)= -99999.9
        ENDIF
        IF(netlwrf_L .GT. 0.5)THEN
          DO J=1,JSUB
	  DO I=1,ISUB
            netlwrf(i,j)=dlwrf(i,j)-ulwrf(i,j)
	  ENDDO
	  ENDDO
	ELSE
            netlwrf(i,j)=-99999.9
        ENDIF
        IF(netswrf_L .GT. 0.5)THEN
          DO J=1,JSUB
	  DO I=1,ISUB
            netswrf(i,j)=dswrf(i,j)-uswrf(i,j)
	  ENDDO
	  ENDDO
	ELSE
            netswrf(i,j)=-99999.9
        ENDIF

!! For RUC products, net short wave and long wave radiation fluxes are provided
400     CONTINUE
        IF (trim(DBASE) .EQ. 'RUC')THEN
          FNAME='NLWRS.'//trim(DBASE)
        WRITE(*,*)'READING ',TRIM(FNAME)
          INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
	  IF(FEXIST .and. (.NOT. FOPEN))OPEN(90,file=trim(FNAME))
          IF(.NOT.FEXIST)THEN
            DO J=1,JSUB
	    DO I=1,ISUB
             netlwrf(i,j)=-99999.9 
	    ENDDO
	    ENDDO
          ELSE
	    READ(90,'(a)',end=2328)BUFFER
            IND=INDEX(BUFFER,'d=')
	    IF(IND .LE. 0)THEN
	      WRITE(*,*)'record does not include time info'
	      STOP
	    ENDIF   
	    IND_DATE=IND+2
            IND_HOUR=IND+12
            IND_HOUR_END=INDEX(BUFFER,'hour')-1
            IND=INDEX(BUFFER,'-',BACK=.TRUE.)
            IF(IND .GT. 0)IND_HOUR=IND+1
	    READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
            IND=INDEX(BUFFER,'anl')
	    IF(IND .GT. 0)THEN
	      IHH=00
	    ELSE
	      READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
	    ENDIF   
            yearb=IYR
            monthb=IMM
            dayb=IDD
            hourb=ihh+ICYC
            time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
	    if(time .lt. 0.0)time=time0
	    IF(time0 .GE.time)THEN
              DO J=1,JM
	      DO I=1,IM
	        READ(90,*)x,y,value
                tmp1(i,j)=value 
              ENDDO
	      ENDDO
              DO J=1,JSUB
	      DO I=1,ISUB
                netlwrf(i,j)=tmp1(IMIN+I-1,JMIN+J-1)*SCALE_HFLUX !ading scaling factor ro reduce NAM HFLUX 
	      ENDDO
	      ENDDO    
	    ELSE
	      BACKSPACE (90)
              DO J=1,JSUB
	      DO I=1,ISUB
                netlwrf(i,j)=-99999.9 
	      ENDDO
	      ENDDO
            ENDIF
	  ENDIF  
2328      continue
          FNAME='NSWRS.'//trim(DBASE)
          WRITE(*,*)'READING ',TRIM(FNAME)
          INQUIRE(FILE=TRIM(FNAME),EXIST=FEXIST,OPENED=FOPEN)
	  IF(FEXIST .and. (.NOT. FOPEN))OPEN(91,file=trim(FNAME))
          IF(.NOT.FEXIST)THEN
            DO J=1,JSUB
	    DO I=1,ISUB
             netswrf(i,j)=-99999.9 
	    ENDDO
	    ENDDO
          ELSE
	    READ(91,'(a)',end=2330)BUFFER
            IND=INDEX(BUFFER,'d=')
	    IF(IND .LE. 0)THEN
	      WRITE(*,*)'record does not include time info'
	      STOP
	    ENDIF   
	    IND_DATE=IND+2
            IND_HOUR=IND+12
            IND_HOUR_END=INDEX(BUFFER,'hour')-1
            IND=INDEX(BUFFER,'-',BACK=.TRUE.)
            IF(IND .GT. 0)IND_HOUR=IND+1

	    READ(BUFFER(IND_DATE:IND_DATE+9),'(I4,3I2)')IYR,IMM,IDD,ICYC
            IND=INDEX(BUFFER,'anl')
	    IF(IND .GT. 0)THEN
	      IHH=00
	    ELSE
	      READ(BUFFER(IND_HOUR:IND_HOUR_END),*)IHH
	    ENDIF   
            yearb=IYR
            monthb=IMM
            dayb=IDD
            hourb=ihh+ICYC
            time0=JULIAN(yearb,monthb,dayb,hourb)-jbase_date
	    if(time .lt. 0.0)time=time0
	    IF(time0 .GE.time)THEN
              DO J=1,JM
	      DO I=1,IM
	        READ(91,*)x,y,value
                tmp1(i,j)=value 
              ENDDO
	      ENDDO
              DO J=1,JSUB
	      DO I=1,ISUB
                netswrf(i,j)=tmp1(IMIN+I-1,JMIN+J-1)*SCALE_HFLUX !ading scaling factor ro reduce NAM HFLUX 
	      ENDDO
	      ENDDO    
	    ELSE
	      BACKSPACE (91)
              DO J=1,JSUB
	      DO I=1,ISUB
                 netswrf(i,j)=-99999.9 
	      ENDDO
	      ENDDO
            ENDIF
	  ENDIF
2330      continue  
!! AJ sign convention of sensiable and latent heat flux for NAM and GFS is as, positive for upwards (out of ocean)	
          DO J=1,JSUB
	  DO I=1,ISUB
            nflux(i,j)= netswrf(i,j)+netlwrf(i,j)
     1                  -lhtfl(I,J)-shtfl(I,J)
	  ENDDO
	  ENDDO
        ENDIF
C Rotate U and V components from Lambert Conformal projection (AWIPS Grid 218) 
C to earth coordinates true eastly and northly wind components
C since Longitude is negative in west (minus 360), so the parameter Lov =LoV - 360 = -995
!        IF (trim(DBASE) .EQ. 'NAM'  .or. 
!     &	   (trim(DBASE) .EQ. 'NAM4').or.
!     &     (trim(DBASE) .EQ. 'NDFD').or.
!     &	   (trim(DBASE) .EQ. 'RTMA').or.
!     &     (trim(DBASE) .EQ. 'RUC') )THEN
        IF ( (trim(DBASE) .NE. "GFS") .AND.
     1       (trim(DBASE) .NE. "GFS25") )THEN
            LON_XX_P=LoV -360.0
	    LAT_XX_P=LaD
	    ROTCON_P=sin(D2R*LAT_XX_P)
            DO J=1,JSUB
            DO I=1,ISUB
              if (uwind(i,j) .GT. -999.0 .AND.
     1            vwind(i,j) .GT. -999.0 )then
                 ANGLE=ROTCON_P*(lonsub(I,J)-LON_XX_P)*D2R
                 SINX2=SIN(ANGLE)
                 COSX2=COS(ANGLE)
                 ut=uwind(i,j)
                 vt=vwind(i,j)
                 Uwind(I,J)= COSX2 * ut + SINX2 * VT
                 Vwind(I,J)= -SINX2 * ut + COSX2 * VT
              else
                 Uwind(I,J)=-99999.9
                 Vwind(I,J)=-99999.9
              endif
            ENDDO
            ENDDO
	ENDIF  

        DO J=1,JSUB !replace land values with closest coastal value
        DO I=1,ISUB
           uwind(I,J)=uwind(IFILL(I,J),JFILL(I,J))
           vwind(I,J)=vwind(IFILL(I,J),JFILL(I,J))
           pair(I,J)=pair(IFILL(I,J),JFILL(I,J))
           tair(I,J)=tair(IFILL(I,J),JFILL(I,J))
           qair(I,J)=qair(IFILL(I,J),JFILL(I,J))
           netswrf(I,J)=netswrf(IFILL(I,J),JFILL(I,J))
           dlwrf(I,J)=dlwrf(IFILL(I,J),JFILL(I,J))
           prate(I,J)=prate(IFILL(I,J),JFILL(I,J))
           tcdc(I,J)=tcdc(IFILL(I,J),JFILL(I,J))
           evp(I,J)=evp(IFILL(I,J),JFILL(I,J))
        ENDDO
        ENDDO

        IF (IGRD .LE. 0 )THEN     !!  no spatial interpolation
	   IF( (TIME .GT. TIME_START+0.001) .AND. (N .EQ. 1) )THEN  ! extra-interpolating to cover simulation period
	    call write_netCDF_surfaceforcing_ROMS(OUTPUTFILE,ncid,2,
     &      IGRD,ISUB,JSUB,base_date,lonsub,latsub,time_start,
     &      uwind,vwind,pair,tair,qair,netswrf,dlwrf,
     &      prate,tcdc,evp,globalstr)
           ENDIF
	   call write_netCDF_surfaceforcing_ROMS(OUTPUTFILE,ncid,2,
     &     IGRD,ISUB,JSUB,base_date,lonsub,latsub,time,uwind,vwind,
     &     pair,tair,qair,netswrf,dlwrf,
     &     prate,tcdc,evp,globalstr)

	ELSEIF (IGRD .EQ. 1 )THEN   !! spatial interpolation using remesh
            if (allocated(oned1)) deallocate(oned1)
            if (allocated(oned2)) deallocate(oned2)
            if (allocated(oned3)) deallocate(oned3)
            allocate(oned1(NNSUB))
            allocate(oned2(NNSUB))
            allocate(oned3(NNSUB))
!           CALL TWO2ONED(ZINP,uwind,ISUB,JSUB)
            IF (Uwind_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (uwind(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=uwind(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of uwind= ',NTMP,NTMP0,N
!             call INTERP_REMESH(NNSUB,XINP,YINP,ZINP,
              IF (NTMP0 .ne. NTMP)then
                NTMP0=NTMP
                call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *          NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,0)
              endif
              call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,1)
              CALL ONE2TWOD(ZOUT,uwindm,IROMS,JROMS)
            ENDIF
             IF (vwind_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (vwind(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=vwind(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of vwind= ',NTMP,NTMP0,N
!             call INTERP_REMESH(NNSUB,XINP,YINP,ZINP,
              IF (NTMP0 .ne. NTMP)then
                NTMP0=NTMP
                call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *          NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,0)
              endif
              call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,1)
              CALL ONE2TWOD(ZOUT,vwindm,IROMS,JROMS)
            ENDIF
             IF (pair_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (pair(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=pair(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of pair= ',NTMP,NTMP0,N
!             call INTERP_REMESH(NNSUB,XINP,YINP,ZINP,
              IF (NTMP0 .ne. NTMP)then
                NTMP0=NTMP
                call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *          NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,0)
              endif
              call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,1)
              CALL ONE2TWOD(ZOUT,pairm,IROMS,JROMS)
            ENDIF
            IF (tair_L .gt. 0.0)then

              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (tair(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=tair(i,j)
                endif
              ENDDO
              ENDDO
               print *,'NTMP of tair= ',NTMP,NTMP0,N
              IF (NTMP0 .ne. NTMP)then
                NTMP0=NTMP
                call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *          NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,0)
              ENDIF
              call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,1)
              CALL ONE2TWOD(ZOUT,tairm,IROMS,JROMS)
            ENDIF
            IF (qair_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (qair(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=qair(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of qair= ',NTMP,NTMP0,N
              IF (NTMP0 .ne. NTMP)then
                NTMP0=NTMP
                call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *          NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,0)
              ENDIF
              call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,1)
              CALL ONE2TWOD(ZOUT,qairm,IROMS,JROMS)
            ENDIF
            IF (tcdc_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (tcdc(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=tcdc(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of tcdc= ',NTMP,NTMP0,N
              IF (NTMP0 .ne. NTMP)then
                NTMP0=NTMP
                call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *          NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,0)
              ENDIF
              call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,1)
              CALL ONE2TWOD(ZOUT,tcdcm,IROMS,JROMS)
            ENDIF
            IF (tdair_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (tdair(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=tdair(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of dpt= ',NTMP,NTMP0,N
              IF (NTMP0 .ne. NTMP)then
                NTMP0=NTMP
                call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *          NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,0)
              ENDIF
              call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,1)
              CALL ONE2TWOD(ZOUT,tdairm,IROMS,JROMS)
            ENDIF
            IF (dswrf_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (dswrf(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=dswrf(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of dswrf= ',NTMP,NTMP0,N
              IF (NTMP0 .ne. NTMP)then
                NTMP0=NTMP
                call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *          NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,0)
              ENDIF
              call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,1)
              CALL ONE2TWOD(ZOUT,dswrfm,IROMS,JROMS)
            ENDIF

            IF (dlwrf_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (dlwrf(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=dlwrf(i,j)
                endif
              ENDDO
              ENDDO
              IF (NTMP0 .ne. NTMP)then
                NTMP0=NTMP
                call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *          NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,0)
              ENDIF
              call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,1)
              CALL ONE2TWOD(ZOUT,dlwrfm,IROMS,JROMS)
            ENDIF
            IF (nflux_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (nflux(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=nflux(i,j)
                endif
              ENDDO
              ENDDO
              IF (NTMP0 .ne. NTMP)then
                NTMP0=NTMP
                call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *          NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,0)
              ENDIF
              call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,1)
              CALL ONE2TWOD(ZOUT,nfluxm,IROMS,JROMS)
            ENDIF
            IF (netswrf_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (netswrf(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=netswrf(i,j)
                endif
              ENDDO
              ENDDO
              IF (NTMP0 .ne. NTMP)then
                NTMP0=NTMP
                call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *          NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,0)
              ENDIF
              call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,1)
               CALL ONE2TWOD(ZOUT,netswrfm,IROMS,JROMS)
            ENDIF
            IF (spfh_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (spfh(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=spfh(i,j)
                endif
              ENDDO
              ENDDO
              IF (NTMP0 .ne. NTMP)then
                NTMP0=NTMP
                call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *          NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,0)
              ENDIF
              call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,1)
              CALL ONE2TWOD(ZOUT,spfhm,IROMS,JROMS)
            ENDIF
            IF (prate_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (prate(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=prate(i,j)
                endif
              ENDDO
              ENDDO
              IF (NTMP0 .ne. NTMP)then
                NTMP0=NTMP
                call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *          NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,0)
              ENDIF
              call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,1)
              CALL ONE2TWOD(ZOUT,pratem,IROMS,JROMS)
            ENDIF
            IF (evp_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (evp(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=evp(i,j)
                endif
              ENDDO
              ENDDO
              IF (NTMP0 .ne. NTMP)then
                NTMP0=NTMP
                call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *          NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,0)
              ENDIF
              call INTERP_REMESH(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT,weightnodes,weights,1)
              CALL ONE2TWOD(ZOUT,evpm,IROMS,JROMS)
            ENDIF

!	    CALL ONE2TWOD(ZOUT,pratem,IROMS,JROMS)
	ELSEIF (IGRD .EQ. 2 .or. IGRD .EQ. 3)THEN   !! spatial interpolation using bicubic or bilinear
            if( IGRD .eq. 2)iflag=1
            if( IGRD .eq. 3)iflag=0
            CALL INTERP_REGRID(iflag,ISUB,JSUB,lonsub,latsub,uwind,
     &           IROMS,JROMS,lonm,latm,uwindm,Iout,Jout,0)
            IF (Uwind_L .GT. 0) THEN
            CALL INTERP_REGRID(iflag,ISUB,JSUB,lonsub,latsub,uwind,
     &           IROMS,JROMS,lonm,latm,uwindm,Iout,Jout,1)
            ENDIF
            IF (Vwind_L .GT. 0) THEN
            CALL INTERP_REGRID(iflag,ISUB,JSUB,lonsub,latsub,vwind,
     &           IROMS,JROMS,lonm,latm,vwindm,Iout,Jout,1) 	 
            ENDIF
            IF (pair_L .GT. 0) THEN
            CALL INTERP_REGRID(iflag,ISUB,JSUB,lonsub,latsub,pair,
     &           IROMS,JROMS,lonm,latm,pairm,Iout,Jout,1) 	 
            ENDIF
            IF (tair_L .GT. 0) THEN
            CALL INTERP_REGRID(iflag,ISUB,JSUB,lonsub,latsub,tair,
     &           IROMS,JROMS,lonm,latm,tairm,Iout,Jout,1) 	 
            ENDIF
            IF (qair_L .GT. 0) THEN
            CALL INTERP_REGRID(iflag,ISUB,JSUB,lonsub,latsub,qair,
     &           IROMS,JROMS,lonm,latm,qairm,Iout,Jout,1) 	 
            ENDIF
            IF (netswrf_L .GT. 0) THEN
            CALL INTERP_REGRID(iflag,ISUB,JSUB,lonsub,latsub,netswrf,
     &           IROMS,JROMS,lonm,latm,netswrfm,Iout,Jout,1) 	 
            ENDIF
            IF (dlwrf_L .GT. 0) THEN
            CALL INTERP_REGRID(iflag,ISUB,JSUB,lonsub,latsub,dlwrf,
     &           IROMS,JROMS,lonm,latm,dlwrfm,Iout,Jout,1) 	 
            ENDIF
            IF (prate_L .GT. 0) THEN
            CALL INTERP_REGRID(iflag,ISUB,JSUB,lonsub,latsub,prate,
     &           IROMS,JROMS,lonm,latm,pratem,Iout,Jout,1) 	 
            ENDIF
            IF (tcdc_L .GT. 0) THEN
            CALL INTERP_REGRID(iflag,ISUB,JSUB,lonsub,latsub,tcdc,
     &           IROMS,JROMS,lonm,latm,tcdcm,Iout,Jout,1) 	 
            ENDIF
            IF (evp_L .GT. 0) THEN
            CALL INTERP_REGRID(iflag,ISUB,JSUB,lonsub,latsub,evp,
     &           IROMS,JROMS,lonm,latm,ecpm,Iout,Jout,1) 	 
            ENDIF

	ELSEIF (IGRD .EQ. 4)THEN   !! spatial interpolation using nature neighbors
            if (allocated(oned1)) deallocate(oned1)
            if (allocated(oned2)) deallocate(oned2)
            if (allocated(oned3)) deallocate(oned3)
            allocate(oned1(NNSUB))
            allocate(oned2(NNSUB))
            allocate(oned3(NNSUB))
            IF (Uwind_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (uwind(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=uwind(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of uwind= ',NTMP,NTMP0,N
              call INTERP_NNEIGHBORS(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT)
              CALL ONE2TWOD(ZOUT,uwindm,IROMS,JROMS)
            endif
            IF (vwind_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (vwind(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=vwind(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of vwind= ',NTMP,NTMP0,N
              call INTERP_NNEIGHBORS(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT)
              CALL ONE2TWOD(ZOUT,vwindm,IROMS,JROMS)
            endif
            IF (pair_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (pair(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=pair(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of pair= ',NTMP,NTMP0,N
              call INTERP_NNEIGHBORS(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT)
              CALL ONE2TWOD(ZOUT,pairm,IROMS,JROMS)
            endif
            IF (tair_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (tair(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=tair(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of tair= ',NTMP,NTMP0,N
              call INTERP_NNEIGHBORS(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT)
              CALL ONE2TWOD(ZOUT,tairm,IROMS,JROMS)
            endif
            IF (qair_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (qair(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=qair(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of qair= ',NTMP,NTMP0,N
              call INTERP_NNEIGHBORS(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT)
              CALL ONE2TWOD(ZOUT,qairm,IROMS,JROMS)
            endif
            IF (dswrf_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (dswrf(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=dswrf(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of dswrf= ',NTMP,NTMP0,N
              call INTERP_NNEIGHBORS(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT)
              CALL ONE2TWOD(ZOUT,dswrfm,IROMS,JROMS)
            endif
            IF (dlwrf_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (dlwrf(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=dlwrf(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of dlwrf= ',NTMP,NTMP0,N
              call INTERP_NNEIGHBORS(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT)
              CALL ONE2TWOD(ZOUT,dlwrfm,IROMS,JROMS)
            endif
            IF (netswrf_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (netswrf(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=netswrf(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of netswrf= ',NTMP,NTMP0,N
              call INTERP_NNEIGHBORS(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT)
              CALL ONE2TWOD(ZOUT,netswrfm,IROMS,JROMS)
            endif

            IF (prate_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (prate(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=prate(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of prate= ',NTMP,NTMP0,N
              call INTERP_NNEIGHBORS(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT)
              CALL ONE2TWOD(ZOUT,pratem,IROMS,JROMS)
            endif

            IF (tcdc_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (tcdc(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=tcdc(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of tcdc= ',NTMP,NTMP0,N
              call INTERP_NNEIGHBORS(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT)
              CALL ONE2TWOD(ZOUT,tcdcm,IROMS,JROMS)
            ENDIF

            IF (evp_L .gt. 0.0)then
              NTMP=0
              DO I=1,ISUB
              DO J=1,JSUB
                if (evp(I,J) .GT. -999.0)then
                  NTMP=NTMP+1
                  oned1(NTMP)=lonsub(i,j)
                  oned2(NTMP)=latsub(i,j)
                  oned3(NTMP)=evp(i,j)
                endif
              ENDDO
              ENDDO
              print *,'NTMP of evp= ',NTMP,NTMP0,N
              call INTERP_NNEIGHBORS(NTMP,oned1,oned2,oned3,
     *        NNMODEL,XOUT,YOUT,ZOUT)
              CALL ONE2TWOD(ZOUT,evpm,IROMS,JROMS)
            endif

!	    CALL TWO2ONED(ZINP,spfh,ISUB,JSUB)
!            call INTERP_NNEIGHBORS(NNSUB,XINP,YINP,ZINP,
!     *        NNMODEL,XOUT,YOUT,ZOUT)
!	    CALL ONE2TWOD(ZOUT,spfhm,IROMS,JROMS)
     
!	    CALL TWO2ONED(ZINP,prate,ISUB,JSUB)
!            call INTERP_NNEIGHBORS(NNSUB,XINP,YINP,ZINP,
!     *        NNMODEL,XOUT,YOUT,ZOUT)
!	    CALL ONE2TWOD(ZOUT,pratem,IROMS,JROMS)

	ENDIF 
CC  Rotate u & v components to ROMS curvilinear grid (ROMS local coordinates)	       
        IF (IGRD .GT. 0)THEN
            DO I=1,IROMS
            DO J=1,JROMS
	       ut=uwindm(i,j)
	       vt=vwindm(i,j)
	       uwindm(i,j)=ut*cos(angm(i,j))+vt*sin(angm(i,j))
	       vwindm(i,j)=-ut*sin(angm(i,j))+vt*cos(angm(i,j))
            ENDDO
	    ENDDO
	    PRINT *,'TIME=',TIME,TIME0,IYR,IMM,IDD,ICYC,IHH
	   IF( (TIME .GT. TIME_START) .AND. (N .EQ. 1) )THEN
	    call write_netCDF_surfaceforcing_ROMS(OUTPUTFILE,ncid,2,
     &          IGRD,IROMS,JROMS,base_date,lonm,latm,TIME_START,uwindm,
     &          vwindm,pairm,tairm,qairm,netswrfm,dlwrfm,
     &          pratem,tcdcm,evpm,globalstr)
           ENDIF
	    call write_netCDF_surfaceforcing_ROMS(OUTPUTFILE,ncid,2,
     &          IGRD,IROMS,JROMS,base_date,lonm,latm,time,uwindm,
     &          vwindm,pairm,tairm,qairm,netswrfm,dlwrfm,
     &          pratem,tcdcm,evpm,globalstr)
      
	ENDIF         

300     CONTINUE	  
      ENDDO
99    continue
!! close all NetCDF files for output
      IF (IGRD .GT. 0)THEN
	   IF (TIME0 .LT. TIME_END )THEN !persistence to cover the simulation period
	    call write_netCDF_surfaceforcing_ROMS(OUTPUTFILE,ncid,2,
     &          IGRD,IROMS,JROMS,base_date,lonm,latm,TIME_END,uwindm,
     &          vwindm,pairm,tairm,qairm,netswrfm,dlwrfm,
     &          pratem,tcdcm,evpm,globalstr)
           ENDIF
	   call write_netCDF_surfaceforcing_ROMS(OUTPUTFILE,ncid,3,
     &     IGRD,IROMS,JROMS,base_date,lonm,latm,time,uwindm,vwindm,
     &     pairm,tairm,qairm,netswrfm,dlwrfm,
     &     pratem,tcdcm,evpm,globalstr)
      ELSE
	   IF (TIME0 .LT. TIME_END )THEN !persistence to cover the simulation period
	     call write_netCDF_surfaceforcing_ROMS(OUTPUTFILE,ncid,3,
     &       IGRD,ISUB,JSUB,base_date,lonsub,latsub,time_end,
     &       uwind,vwind,pair,tair,qair,netswrf,dlwrf,
     &       pratem,tcdcm,evpm,globalstr)
           ENDIF
	   call write_netCDF_surfaceforcing_ROMS(OUTPUTFILE,ncid,3,
     &     IGRD,ISUB,JSUB,base_date,lonsub,latsub,time,uwind,vwind,
     &     pair,tair,qair,netswrf,dlwrf,
     &     pratem,tcdcm,evpm,globalstr)

      ENDIF
      WRITE(*,*)'nos_ofs_create_forcing_met.f is COMPLETED SUCCESSFULLY'
      END
      
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE RDGRB2DIMS                 ######
!######                                                      ######
!######                     Developed by                     ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!

      SUBROUTINE rdgrb2dims(gribfile,grbflen,nx_grb,ny_grb,iret
     & ,latsw,lonsw,LaD,LoV,dx_grb,GRIDID)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  This subroutine extracts dimension sizes from GRIB2 file
!
!  The decoder of GRIB2 is from NCEP.
!
!  NOTE: It is intended to be called from root processor only.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: Yunheng Wang
!  08/20/2007
!
!  MODIFICATIONS:
!
!-----------------------------------------------------------------------
!
!  INPUT:
!
!    gribfile      GRIB file name
!    grbflen       Length of GRIB file name
!
!  OUTPUT:
!
!    nx_grb        x-direction grid length
!    ny_grb        y-direction grid length
!
!    iret          Return flag
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
      USE GRIB_MOD

      IMPLICIT NONE

      INTEGER, INTENT(IN) :: grbflen

      CHARACTER(LEN=*), INTENT(IN) :: gribfile

      INTEGER, INTENT(OUT) :: nx_grb       ! Number of points along x-axis
      INTEGER, INTENT(OUT) :: ny_grb       ! Number of points along y-axis

      INTEGER, INTENT(OUT) :: iret        ! Return flag
      INTEGER, INTENT(OUT) ::  GRIDID     !Model Grid index

!
!-----------------------------------------------------------------------
!
!  Temporary arrays to read GRIB file
!
!-----------------------------------------------------------------------
!
      INTEGER :: grbunit

      INTEGER, PARAMETER :: maxlen = 32000
      CHARACTER(LEN=1), ALLOCATABLE :: cgrib(:)

      TYPE(gribfield) :: gfld
!
!-----------------------------------------------------------------------
!
!  Misc internal variables
!
!-----------------------------------------------------------------------
!
!  LOGICAL             :: verbose = .FALSE.
      CHARACTER(LEN=12), PARAMETER :: cmd     = 'rdgrib2dims: '

      INTEGER :: i,j,k,m,n,ij,IERR 
      INTEGER :: iyr,  imo,  iday,  ihr,  fhr
      INTEGER :: iseek, icount, itot
      INTEGER :: lgrib, lgribin, lskip

      INTEGER :: currlen
      INTEGER :: iscan, jscan, ijscan
      INTEGER :: ibgn, iinc, iend, jbgn, jinc, jend
      INTEGER :: listsec0(3), listsec1(13)
      INTEGER :: numfields, numlocal, maxlocal

      INTEGER :: itemp
      real latsw,lonsw,LaD,LoV,dx_grb ,dy_grb,xi,xj
      real alat,alon,lattru1,lattru2
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!-----------------------------------------------------------------------
!
!  Open the GRIB file
!
!-----------------------------------------------------------------------
!
      WRITE(6,'(1x,8A)') cmd, 'Opening GRIB ', gribfile(1:grbflen)
      grbunit=10
      CALL baopenr(grbunit,gribfile(1:grbflen),iret)

      IF  ( iret /= 0 )  THEN
        WRITE(6,'(a,a,/,a,i4)')                                             
     &   'ERROR in opening file ',gribfile(1:grbflen),                   
     &   'function baopenr return status: ',iret
        RETURN
      END IF

!-----------------------------------------------------------------------
!
! Loop over all records
!
!-----------------------------------------------------------------------

      iseek   = 0
      iret = 0

      CALL skgb(grbunit,iseek,maxlen,lskip,lgrib)
      IF (lgrib == 0) THEN
        iret = -3
        RETURN
      END IF

      ALLOCATE(cgrib(lgrib), STAT = iret)

      CALL baread(grbunit,lskip,lgrib,lgribin,cgrib)   ! read a GRIB message
      IF (lgrib /= lgribin) THEN
         WRITE(6,'(2(a,I6))')                                              
     &'ERROR: GRIB2 message size in error, required size = ',lgrib,  
     &', read-in size = ',lgribin
      iret = -3
      RETURN
      END IF

      CALL gb_info(cgrib,lgrib,listsec0,listsec1,                         
     &           numfields,numlocal,maxlocal,iret)
      IF (iret /= 0) THEN
        WRITE(6,'(a,I3)') 'ERROR: quering GRIB2 message = ',iret
        RETURN
      END IF
!!!!!!!!!!!!
      write(*,*)'output from gb_info...'
      write(*,*)'listsec0= ',listsec0
      write(*,*)'listsec1= ',listsec1
      write(*,*)numfields,numlocal,maxlocal
!!!
      CALL gf_getfld(cgrib,lgrib,1,.TRUE.,.TRUE.,gfld,iret)
      IF (iret /= 0) THEN
       WRITE(6,'(a,I3)') 'ERROR: Decoding GRIB2 message = ',iret
       RETURN
      END IF
  !!!!!!!!!!!!!!
      GRIDID=gfld%igdtnum
      write(*,*)'dimension # .. '
      write(*,*)'gfld%ifldnum=',gfld%ifldnum
      write(*,*)'gfld%igdtnum=',gfld%igdtnum
      write(*,*)'gfld%igdtlen=',gfld%igdtlen
      write(*,*)'gfld%ipdtnum=',gfld%ipdtnum
      write(*,*)'gfld%ndpts= ',gfld%ndpts
      write(*,*)'num_coord= ',gfld%num_coord
      write(*,*)'idsect= ',gfld%idsect
      write(*,*)'gfld%griddef= ',gfld%griddef
      write(*,*)'idrtnum= ',gfld%idrtnum
      write(*,*)'idrttmp= ',gfld%idrtmpl
      write(*,*)'gfld%ipdtmpl= ',gfld%ipdtmpl
      write(*,*)'gfld%idsect= ',gfld%idsect
      itemp = gfld%ipdtmpl(5)         ! indicator of model see ON388 Table A
      IF (gfld%idsect(1) == 7) THEN   !US NWS 
        IF (itemp == 83 .OR. itemp == 84) THEN
          WRITE(6,'(1x,a,/)') 'NCEP NAM model'
        ELSE IF (itemp == 81 .OR. itemp == 96) THEN
	
          WRITE(6,'(1x,a,/)') 'NCEP GFS model'
        ELSE IF (itemp == 140) THEN
	
          WRITE(6,'(1x,a,/)') 'NCEP NARR model'
        ELSE IF (itemp == 150) THEN
	
          WRITE(6,'(1x,a,/)') 'NCEP RIVER FORECAST SYSTEM'
        ELSE IF (itemp == 183) THEN
	
          WRITE(6,'(1x,a,/)') 'NDFD products generated by NCEP'
        ELSE IF (itemp == 109) THEN
	
          WRITE(6,'(1x,a,/)') 'RTMA-Real Time Mesoscale Analysis'
        ELSE IF (itemp == 46) THEN
	
          WRITE(6,'(1x,a,/)') 'HYCOM- Global'
        ELSE IF (itemp == 47) THEN
	
          WRITE(6,'(1x,a,/)') 'HYCOM North Pacific Basin'
        ELSE IF (itemp == 48) THEN
	
          WRITE(6,'(1x,a,/)') 'HYCOM North Atlantic Basin'
        ELSE
         WRITE(6,'(1x,a,I3,/)')'Unkown model from NCEP, model=',itemp
        END IF
      ELSE IF (gfld%idsect(1) == 8 .AND. itemp == 0) THEN
         WRITE(6,'(1x,a,/)') 'NDFD products generated by NCEP'
      ELSE 
        WRITE(6,'(1x,a,I2,a,I2,/)')                                   
     & 'Unknown model and orig center, center = ',gfld%idsect(1),  
     & ' model = ',itemp
      END IF

      IF (gfld%igdtnum == 0) THEN       ! Lat/Lon grid
        nx_grb    = gfld%igdtmpl(8)
        ny_grb    = gfld%igdtmpl(9)
        dx_grb    = gfld%igdtmpl(17)/1.0E6  ! in degree
        dy_grb    = gfld%igdtmpl(18)/1.0E6  ! in degree
        iscan     = IAND(gfld%igdtmpl(19),128)/128  ! get the first bit
                    ! = 0, +x(+i) direction, = 1, -x(-i) direction
        jscan     = IAND(gfld%igdtmpl(19),64) / 64   ! get the second bit
                    ! = 0, -y(-j) direction, = 1, +y(+j) direction
        ijscan    = IAND(gfld%igdtmpl(19),32) / 32   ! get the third bit
                    ! = 0, x direction first, = 1, y direction first

!        uvearth   = IAND(gfld%igdtmpl(14),8)  /  8   ! get the fifth bit, big-endian
        IF (jscan == 1) THEN          ! +y(+j) direction
          latsw     = gfld%igdtmpl(12)/1.0E6
          lonsw     = gfld%igdtmpl(13)/1.0E6
        ELSE                          ! -y(-j) direction
          latsw     = gfld%igdtmpl(15)/1.0E6
          lonsw     = gfld%igdtmpl(13)/1.0E6
        END IF
        write(*,*)'nx & ny= ',nx_grb,ny_grb
        write(*,*)'lat and lon of southwest corner grid=',latsw,lonsw
 !       write(*,*)'LaD & LoV= ',LaD,LoV
        write(*,*)'igtmp= ',gfld%igdtmpl

      ELSE IF (gfld%igdtnum == 30) THEN ! Lambert Conformal Grid
!    iproj_grb   = 2
        nx_grb      = gfld%igdtmpl(8)
        ny_grb      = gfld%igdtmpl(9)
        latsw       = gfld%igdtmpl(10)/1.0E6  ! in degrees
        lonsw       = gfld%igdtmpl(11)/1.0E6  ! in degrees
        LaD      = gfld%igdtmpl(13)/1.0E6  ! in degrees
        LoV     = gfld%igdtmpl(14)/1.0E6  ! in degrees
        dx_grb      = gfld%igdtmpl(15)/1.0E3  ! in degrees
        dy_grb      = gfld%igdtmpl(16)/1.0E3  ! in degrees
        lattru1     = gfld%igdtmpl(19)/1.0E6  ! in degrees
        lattru2     = gfld%igdtmpl(20)/1.0E6  ! in degrees
        write(*,*)'nx & ny= ',nx_grb,ny_grb
        write(*,*)'lat and lon of southwest corner grid=',latsw,lonsw
        write(*,*)'LaD & LoV= ',LaD,LoV
        write(*,*)'igtmp= ',gfld%igdtmpl
        DO xI=1, nx_grb
        DO xJ=1,ny_grb
         CALL W3FB12(xI,xJ,latsw,lonsw,dx_grb,LoV,LaD,alat,alon,IrEt)
   !       write(*,*)'lat & lon I J= ',alat,alon,xi,xj
        ENDDO
        ENDDO
      ELSE IF (gfld%igdtnum == 20) THEN ! Polar-Stereographic Grid
!    iproj_grb   = 1
        nx_grb      = gfld%igdtmpl(8)
        ny_grb      = gfld%igdtmpl(9)
!    lattru1     = 60.
!    lattru2     = 91.
!    latsw       = gfld%igdtmpl(10)
!    lonsw       = gfld%igdtmpl(11)

      ELSE
       WRITE(6,'(1x,a,I3)') 'Unkown projection: ',gfld%igdtnum
       iret = -3
       RETURN
      END IF

!-----------------------------------------------------------------------
!
! Close file and release the gribfield before returning
!
!-----------------------------------------------------------------------

      CALL gf_free( gfld )
      CALL baclose( grbunit,iret )

      DEALLOCATE (cgrib)

      RETURN
      END SUBROUTINE rdgrb2dims
C ---------------------------------------------------------------------------------------------------
      




C ---------------------------------------------------------------------------------------------------
       SUBROUTINE W3FB12(XI,XJ,ALAT1,ELON1,DX,ELONV,ALATAN,ALAT,ELON,
     &                               IERR)
C
C$$$   SUBPROGRAM  DOCUMENTATION  BLOCK
C
C SUBPROGRAM:  W3FB12        LAMBERT(I,J) TO LAT/LON FOR GRIB
C   PRGMMR: STACKPOLE        ORG: NMC42       DATE:88-11-28
C
C ABSTRACT: CONVERTS THE COORDINATES OF A LOCATION ON EARTH GIVEN IN A
C   GRID COORDINATE SYSTEM OVERLAID ON A LAMBERT CONFORMAL TANGENT
C   CONE PROJECTION TRUE AT A GIVEN N OR S LATITUDE TO THE
C   NATURAL COORDINATE SYSTEM OF LATITUDE/LONGITUDE
C   W3FB12 IS THE REVERSE OF W3FB11.
C   USES GRIB SPECIFICATION OF THE LOCATION OF THE GRID
C
C PROGRAM HISTORY LOG:
C   88-11-25  ORIGINAL AUTHOR:  STACKPOLE, W/NMC42
C   90-04-12  R.E.JONES   CONVERT TO CFT77 FORTRAN
C   94-04-28  R.E.JONES   ADD SAVE STATEMENT
C
C USAGE:  CALL W3FB12(XI,XJ,ALAT1,ELON1,DX,ELONV,ALATAN,ALAT,ELON,IERR,
C                                   IERR)
C   INPUT ARGUMENT LIST:
C     XI       - I COORDINATE OF THE POINT  real
C     XJ       - J COORDINATE OF THE POINT  real
C     ALAT1    - LATITUDE  OF LOWER LEFT POINT OF GRID (POINT 1,1)
C                LATITUDE <0 FOR SOUTHERN HEMISPHERE; real
C     ELON1    - LONGITUDE OF LOWER LEFT POINT OF GRID (POINT 1,1)
C                  EAST LONGITUDE USED THROUGHOUT; real
C     DX       - MESH LENGTH OF GRID IN METERS AT TANGENT LATITUDE
C     ELONV    - THE ORIENTATION OF THE GRID.  I.E.,
C                THE EAST LONGITUDE VALUE OF THE VERTICAL MERIDIAN
C                WHICH IS PARALLEL TO THE Y-AXIS (OR COLUMNS OF
C                THE GRID) ALONG WHICH LATITUDE INCREASES AS
C                THE Y-COORDINATE INCREASES.  real
C                THIS IS ALSO THE MERIDIAN (ON THE OTHER SIDE OF THE
C                TANGENT CONE) ALONG WHICH THE CUT IS MADE TO LAY
C                THE CONE FLAT.
C     ALATAN   - THE LATITUDE AT WHICH THE LAMBERT CONE IS TANGENT TO
C                (TOUCHES OR OSCULATES) THE SPHERICAL EARTH.
C                 SET NEGATIVE TO INDICATE A
C                 SOUTHERN HEMISPHERE PROJECTION; real
C
C   OUTPUT ARGUMENT LIST:
C     ALAT     - LATITUDE IN DEGREES (NEGATIVE IN SOUTHERN HEMI.)
C     ELON     - EAST LONGITUDE IN DEGREES, real
C     IERR     - .EQ. 0   IF NO PROBLEM
C                .GE. 1   IF THE REQUESTED XI,XJ POINT IS IN THE
C                         FORBIDDEN ZONE, I.E. OFF THE LAMBERT MAP
C                         IN THE OPEN SPACE WHERE THE CONE IS CUT.
C                  IF IERR.GE.1 THEN ALAT=999. AND ELON=999.
C
C   REMARKS: FORMULAE AND NOTATION LOOSELY BASED ON HOKE, HAYES,
C     AND RENNINGER'S "MAP PROJECTIONS AND GRID SYSTEMS...", MARCH 1981
C     AFGWC/TN-79/003
C
C ATTRIBUTES:
C   LANGUAGE: CRAY CFT77 FORTRAN
C   MACHINE:  CRAY C916-128, CRAY Y-MP8/864, CRAY Y-MP EL2/256
C
C$$$
C
         LOGICAL NEWMAP
C
         SAVE
C
         DATA  RERTH /6.3712E+6/, PI/3.14159/, OLDRML/99999./
C
C
C        PRELIMINARY VARIABLES AND REDIFINITIONS
C
C        H = 1 FOR NORTHERN HEMISPHERE; = -1 FOR SOUTHERN
C
         IF (ALATAN.GT.0) THEN
           H = 1.
         ELSE
           H = -1.
         ENDIF
C
         PIBY2  = PI     / 2.0
         RADPD  = PI     / 180.0
         DEGPRD = 1.0    / RADPD
         REBYDX = RERTH  / DX
         ALATN1 = ALATAN * RADPD
         AN     = H * SIN(ALATN1)
         COSLTN = COS(ALATN1)
C
C        MAKE SURE THAT INPUT LONGITUDE DOES NOT PASS THROUGH
C        THE CUT ZONE (FORBIDDEN TERRITORY) OF THE FLAT MAP
C        AS MEASURED FROM THE VERTICAL (REFERENCE) LONGITUDE
C
         ELON1L = ELON1
         IF ((ELON1-ELONV).GT.180.)
     &     ELON1L = ELON1 - 360.
         IF ((ELON1-ELONV).LT.(-180.))
     &     ELON1L = ELON1 + 360.
C
         ELONVR = ELONV * RADPD
C
C        RADIUS TO LOWER LEFT HAND (LL) CORNER
C
         ALA1 =  ALAT1 * RADPD
         RMLL = REBYDX * ((COSLTN**(1.-AN))*(1.+AN)**AN) *
     &           (((COS(ALA1))/(1.+H*SIN(ALA1)))**AN)/AN
C
C        USE RMLL TO TEST IF MAP AND GRID UNCHANGED FROM PREVIOUS
C        CALL TO THIS CODE.  THUS AVOID UNNEEDED RECOMPUTATIONS.
C
         IF (RMLL.EQ.OLDRML) THEN
           NEWMAP = .FALSE.
         ELSE
           NEWMAP = .TRUE.
           OLDRML = RMLL
C
C          USE LL POINT INFO TO LOCATE POLE POINT
C
           ELO1 = ELON1L * RADPD
           ARG = AN * (ELO1-ELONVR)
           POLEI = 1. - H * RMLL * SIN(ARG)
           POLEJ = 1. + RMLL * COS(ARG)
         ENDIF
C
C        RADIUS TO THE I,J POINT (IN GRID UNITS)
C              YY REVERSED SO POSITIVE IS DOWN
C
         XX = XI - POLEI
         YY = POLEJ - XJ
         R2 = XX**2 + YY**2
C
C        CHECK THAT THE REQUESTED I,J IS NOT IN THE FORBIDDEN ZONE
C           YY MUST BE POSITIVE UP FOR THIS TEST
C
         THETA = PI*(1.-AN)
         BETA = ABS(ATAN2(XX,-YY))
         IERR = 0
         IF (BETA.LE.THETA) THEN
           IERR = 1
           ALAT = 999.
           ELON = 999.
           IF (.NOT.NEWMAP)  RETURN
         ENDIF
C
C        NOW THE MAGIC FORMULAE
C
         IF (R2.EQ.0) THEN
           ALAT = H * 90.0
           ELON = ELONV
         ELSE
C
C          FIRST THE LONGITUDE
C
           ELON = ELONV + DEGPRD * ATAN2(H*XX,YY)/AN
           ELON = AMOD(ELON+360., 360.)
C
C          NOW THE LATITUDE
C          RECALCULATE THE THING ONLY IF MAP IS NEW SINCE LAST TIME
C
           IF (NEWMAP) THEN
             ANINV = 1./AN
             ANINV2 = ANINV/2.
             THING = ((AN/REBYDX) ** ANINV)/
     &         ((COSLTN**((1.-AN)*ANINV))*(1.+ AN))
           ENDIF
           ALAT = H*(PIBY2 - 2.*ATAN(THING*(R2**ANINV2)))*DEGPRD
         ENDIF
C
C        FOLLOWING TO ASSURE ERROR VALUES IF FIRST TIME THRU
C         IS OFF THE MAP
C
         IF (IERR.NE.0) THEN
           ALAT = 999.
           ELON = 999.
           IERR = 2
         ENDIF
          XLON=360-ELON
c
C          write(6,111)XI,XJ,ALAT1,ELON1,DX,ELONV,ALATAN,ALAT,ELON,XLON,IERR
c111       format(f6.1,1x,f6.1,1x,5(f9.3,1x),f9.3,1x,f9.3,1x,f9.3,1x,i2)
C
         RETURN
         END
